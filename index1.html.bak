<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Tempest 80s Clone (Three.js)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #4deeea;
            font-family: 'Orbitron', sans-serif;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
        }
        canvas { display: block; }

        /* Shared styles for UI and Menu */
        #ui, #game-over, #menu, #level-complete {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px;
            font-size: 1.2em;
            letter-spacing: 1px;
        }

        #ui {
            top: 20px;
            left: 20px;
            color: #4deeea;
            text-shadow: 0 0 8px rgba(77, 238, 234, 0.8);
            background: rgba(0, 0, 20, 0.5);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid #4deeea;
        }

        #game-over, #level-complete {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: all;
        }

        #game-over {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        #level-complete {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #game-over h1, #level-complete h1 { margin: 0 0 15px 0; font-size: 2.5em;}
        #game-over #final-score, #level-complete #level-score { margin-bottom: 20px; }

        #menu {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffff00;
            padding: 30px;
            text-align: center;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
            pointer-events: all;
            max-width: 90%;
            width: 400px;
            box-sizing: border-box;
        }
        #menu h1 { margin: 0 0 20px 0; font-size: 1.8em; text-shadow: 0 0 10px #ffff00; }
        #menu div { margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;}
        #menu label { margin-right: 10px; white-space: nowrap;}
        #menu select, #menu button, #game-over button, #level-complete button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #000;
            color: #ffff00;
            border: 2px solid #ffff00;
            text-shadow: 0 0 5px #ffff00;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            border-radius: 0;
            min-width: 100px;
        }
        #menu select option {
            background-color: #000;
            color: #ffff00;
        }

        #menu button, #game-over button, #level-complete button {
            width: 100%;
            margin-top: 10px;
        }
        #menu button:hover, #game-over button:hover, #level-complete button:hover {
            text-shadow: 0 0 15px #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        /* Power-up indicator */
        #power-ups {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        /* Level indicator */
        #level-indicator {
            position: absolute;
            top: 50px;
            left: 10px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        /* Pause screen */
        #pause-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff;
            font-size: 2em;
            display: none;
            z-index: 101;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            font-size: 0.8em;
            z-index: 100;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="lives">LIVES: 3</div>
    </div>

    <div id="power-ups">
        <div id="active-power">POWER: NONE</div>
    </div>

    <div id="level-indicator">
        <div id="current-level">LEVEL: 1</div>
    </div>

    <div id="pause-screen">PAUSED</div>

    <div id="instructions">
        ARROWS: MOVE | SPACE: FIRE | P: PAUSE
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <div id="final-score"></div>
        <button id="restart-button">RESTART</button>
    </div>

    <div id="level-complete">
        <h1>LEVEL COMPLETE</h1>
        <div id="level-score"></div>
        <button id="next-level-button">NEXT LEVEL</button>
    </div>

    <div id="menu">
        <h1>TEMPEST CLONE</h1>
        <div>
            <label for="speed-select">PLAYER SPEED:</label>
            <select id="speed-select">
                <option value="slow">SLOW</option>
                <option value="normal" selected>NORMAL</option>
                <option value="fast">FAST</option>
            </select>
        </div>
        <div>
            <label for="direction-speed-select">DIRECTION SPEED:</label>
            <select id="direction-speed-select">
                <option value="slow">SLOW</option>
                <option value="normal" selected>NORMAL</option>
                <option value="fast">FAST</option>
            </select>
        </div>
        <div>
            <label for="difficulty-select">DIFFICULTY:</label>
            <select id="difficulty-select">
                <option value="easy">EASY</option>
                <option value="medium" selected>MEDIUM</option>
                <option value="hard">HARD</option>
            </select>
        </div>
        <div>
            <label for="web-type-select">WEB TYPE:</label>
            <select id="web-type-select">
                <option value="circle" selected>CIRCLE</option>
                <option value="square">SQUARE</option>
                <option value="triangle">TRIANGLE</option>
                <option value="random">RANDOM</option>
            </select>
        </div>
        <button id="start-button">START GAME</button>
    </div>

    <!-- Include Three.js library and additional modules -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let webMesh;
        let player;
        let starfield;
        let playerTrail;
        let composer; // For post-processing effects
        const projectiles = [];
        const enemies = [];
        const powerUps = [];
        const explosions = [];
        const playerTrailParticles = [];
        const keyState = {};

        // Game State
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameover', 'levelcomplete'
        let isPaused = false;

        // Web Configuration
        let NUM_LANES = 16;
        const WEB_DEPTH = 40;
        const WEB_RADIUS = 10;
        let LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;
        let webType = 'circle';

        // Fixed Z positions
        const PLAYER_Z = WEB_DEPTH / 2;
        const ENEMY_START_Z = -WEB_DEPTH / 2 + 1;
        const ENEMY_END_Z = WEB_DEPTH / 2 - 2;

        // Game mechanics
        const PROJECTILE_SPEED = 0.6;
        const COLLISION_Z_TOLERANCE = 1.0;
        const POWER_UP_CHANCE = 0.15; // 15% chance of power-up spawn per enemy kill
        const POWER_UP_DURATION = 10000; // 10 seconds
        const SPECIAL_ENEMY_CHANCE = 0.1; // 10% chance of special enemy

        // Configurable Settings
        let ROTATION_SMOOTHING_FACTOR = 0.1; // Controls how quickly the ship rotates to its target rotation (lower = smoother)
        let playerLaneChangeRate = 12;
        let currentEnemySpeed = 0.05;
        let currentEnemySpawnInterval = 50;
        let enemiesPerLevel = 20;
        let playerTargetRotation = 0; // Target rotation for smooth rotation transitions

        // Game stats
        let score = 0;
        let lives = 3;
        let level = 1;
        let enemiesKilled = 0;
        let enemiesRequired = enemiesPerLevel;
        let enemySpawnTimer = 0;
        let playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
        let lastLaneChangeFrame = 0;
        let activePowerUp = null;
        let powerUpTimer = 0;
        let lastFrameTime = 0;

        // Sound effects (placeholders)
        const sounds = {
            fire: new Audio(),
            explode: new Audio(),
            powerUp: new Audio(),
            levelComplete: new Audio()
        };

        // --- UI Elements ---
        const uiElement = document.getElementById('ui');
        const scoreUI = document.getElementById('score');
        const livesUI = document.getElementById('lives');
        const powerUpUI = document.getElementById('active-power');
        const levelUI = document.getElementById('current-level');
        const pauseScreen = document.getElementById('pause-screen');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreUI = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const levelCompleteScreen = document.getElementById('level-complete');
        const levelScoreUI = document.getElementById('level-score');
        const nextLevelButton = document.getElementById('next-level-button');
        const menuElement = document.getElementById('menu');
        const speedSelect = document.getElementById('speed-select');
        const directionSpeedSelect = document.getElementById('direction-speed-select');
        const difficultySelect = document.getElementById('difficulty-select');
        const webTypeSelect = document.getElementById('web-type-select');
        const startButton = document.getElementById('start-button');

        // --- Initialization Function ---
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000030, 0.01); // Add fog for depth

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                90,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 13.6, WEB_DEPTH / 2 + 15);
            camera.lookAt(0, 0, 0);

            // Renderer setup with improved capabilities
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // Create starfield background
            createStarfield();

            // Add enhanced lighting
            addLighting();

            // Set up post-processing effects
            setupPostProcessing();

            // Create the initial web - it will be recreated with startGame
            createWeb(webType);

            // Create player with enhanced visuals
            createPlayer();
            player.visible = false;

            // Create player trail effect
            createPlayerTrail();

            // Initial state: show menu, hide game UI/game over
            uiElement.style.display = 'none';
            document.getElementById('power-ups').style.display = 'none';
            document.getElementById('level-indicator').style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            menuElement.style.display = 'block';
            document.getElementById('instructions').style.display = 'block';

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            // Button listeners
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', nextLevel);

            // Start the animation loop
            lastFrameTime = performance.now();
            animate();
        }

        // --- Create Starfield Background ---
        function createStarfield() {
            const starCount = 2000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            const starColors = new Float32Array(starCount * 3);

            // Create stars with random positions, sizes, and colors
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                // Position stars in a large sphere around the scene
                const radius = 100 + Math.random() * 900; // 100-1000 units
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                starPositions[i3 + 2] = radius * Math.cos(phi);

                // Random star sizes
                starSizes[i] = Math.random() * 2 + 0.5;

                // Star colors - mostly blue/white with some variation
                const colorChoice = Math.random();
                if (colorChoice > 0.9) { // Red/orange stars (10%)
                    starColors[i3] = 0.8 + Math.random() * 0.2;
                    starColors[i3 + 1] = 0.3 + Math.random() * 0.3;
                    starColors[i3 + 2] = 0.2 + Math.random() * 0.2;
                } else if (colorChoice > 0.7) { // Yellow stars (20%)
                    starColors[i3] = 0.7 + Math.random() * 0.3;
                    starColors[i3 + 1] = 0.7 + Math.random() * 0.3;
                    starColors[i3 + 2] = 0.3 + Math.random() * 0.2;
                } else if (colorChoice > 0.4) { // Blue stars (30%)
                    starColors[i3] = 0.3 + Math.random() * 0.2;
                    starColors[i3 + 1] = 0.5 + Math.random() * 0.3;
                    starColors[i3 + 2] = 0.8 + Math.random() * 0.2;
                } else { // White/blue-white stars (40%)
                    starColors[i3] = 0.8 + Math.random() * 0.2;
                    starColors[i3 + 1] = 0.8 + Math.random() * 0.2;
                    starColors[i3 + 2] = 0.9 + Math.random() * 0.1;
                }
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

            // Create shader material for stars
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    pixelRatio: { value: window.devicePixelRatio }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    uniform float time;
                    uniform float pixelRatio;
                    varying vec3 vColor;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        // Add subtle twinkling effect
                        float twinkle = sin(time * 0.01 + position.x * 0.01 + position.y * 0.01 + position.z * 0.01) * 0.5 + 0.5;
                        gl_PointSize = size * pixelRatio * (1.0 + twinkle * 0.3);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        // Create circular points with soft edges
                        float dist = length(gl_PointCoord - vec2(0.5, 0.5));
                        if (dist > 0.5) discard;

                        // Soften the edges
                        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        // --- Set up Post-Processing Effects ---
        function setupPostProcessing() {
            // Create a render pass
            const renderPass = new THREE.RenderPass(scene, camera);

            // Create a bloom pass for glow effects
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8,    // strength
                0.3,    // radius
                0.7     // threshold
            );

            // Create the effect composer
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }

        // --- Create Player Trail Effect ---
        function createPlayerTrail() {
            playerTrail = new THREE.Group();
            scene.add(playerTrail);
        }

        // --- Add Enhanced Scene Lighting ---
        function addLighting() {
            // Add ambient light for base illumination (slightly brighter)
            const ambientLight = new THREE.AmbientLight(0x333344);
            scene.add(ambientLight);

            // Add directional light for shadows and depth
            const directionalLight = new THREE.DirectionalLight(0xaabbff, 0.6);
            directionalLight.position.set(0, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);

            // Add point light at camera position for dynamic lighting
            const pointLight = new THREE.PointLight(0x4466ff, 1.0, 70);
            pointLight.position.copy(camera.position);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // Add a subtle rim light to highlight edges
            const rimLight = new THREE.DirectionalLight(0x00ffff, 0.3);
            rimLight.position.set(0, -10, -20);
            scene.add(rimLight);

            // Add a subtle pulsing light at the center
            const centerLight = new THREE.PointLight(0x6633ff, 0.8, 30);
            centerLight.position.set(0, 0, 0);
            centerLight.userData = { pulsePhase: 0 }; // For animation
            scene.add(centerLight);
        }

        // --- Create Web Geometry based on selected type ---
        function createWeb(type) {
            // Remove existing web if any
            if (webMesh) {
                scene.remove(webMesh);
            }

            let shape;
            webType = type;

            switch (type) {
                case 'square':
                    shape = createSquareWeb();
                    NUM_LANES = 4; // 4 sides
                    break;
                case 'triangle':
                    shape = createTriangleWeb();
                    NUM_LANES = 3; // 3 sides
                    break;
                case 'random':
                    // Create a random polygon between 5 and 8 sides
                    NUM_LANES = Math.floor(Math.random() * 4) + 5; // 5 to 8 sides
                    shape = createPolygonWeb(NUM_LANES);
                    break;
                case 'circle':
                default:
                    // Circle-like polygon with 16 sides
                    NUM_LANES = 16;
                    shape = createPolygonWeb(NUM_LANES);
                    break;
            }

            // Update LANE_ANGLE_STEP based on NUM_LANES
            LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;

            const extrudeSettings = {
                steps: 1,
                depth: WEB_DEPTH,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.translate(0, 0, -WEB_DEPTH / 2);

            // Create enhanced wireframe with modern holographic effect
            // First, create a solid mesh with transparent material for the "fill"
            const fillMaterial = new THREE.MeshPhongMaterial({
                color: 0x001133,
                emissive: 0x003366,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const fillMesh = new THREE.Mesh(geometry, fillMaterial);

            // Then create the wireframe edges with glowing effect
            const edges = new THREE.EdgesGeometry(geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({
                color: 0x4deeea,
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            const edgeMesh = new THREE.LineSegments(edges, edgeMaterial);

            // Create a group to hold both meshes
            webMesh = new THREE.Group();
            webMesh.add(fillMesh);
            webMesh.add(edgeMesh);

            // Add some random variation to make the web more interesting
            webMesh.rotation.x = 0;
            webMesh.rotation.y = Math.random() * 0.2 - 0.1;

            // Store references for animation
            webMesh.userData = {
                fillMesh: fillMesh,
                edgeMesh: edgeMesh,
                pulsePhase: Math.random() * Math.PI * 2
            };

            scene.add(webMesh);
        }

        // Helper functions to create different web shapes
        function createPolygonWeb(sides) {
            const shape = new THREE.Shape();
            shape.moveTo(WEB_RADIUS, 0);
            for (let i = 1; i <= sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                shape.lineTo(WEB_RADIUS * Math.cos(angle), WEB_RADIUS * Math.sin(angle));
            }
            return shape;
        }

        function createSquareWeb() {
            const shape = new THREE.Shape();
            const size = WEB_RADIUS * 1.5;
            shape.moveTo(size, size);
            shape.lineTo(-size, size);
            shape.lineTo(-size, -size);
            shape.lineTo(size, -size);
            shape.lineTo(size, size);
            return shape;
        }

        function createTriangleWeb() {
            const shape = new THREE.Shape();
            const size = WEB_RADIUS * 1.8;
            shape.moveTo(0, size);
            shape.lineTo(-size, -size/2);
            shape.lineTo(size, -size/2);
            shape.lineTo(0, size);
            return shape;
        }

        // --- Create Player with modern sci-fi visuals ---
        function createPlayer() {
            // Remove existing player if any
            if (player) {
                scene.remove(player);
            }

            // Create a group to hold player elements
            player = new THREE.Group();

            // Main body - use a more complex shape
            const bodyGeometry = new THREE.DodecahedronGeometry(0.8, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x3399ff,
                emissive: 0x0044aa,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2,
                envMapIntensity: 1.0,
                transparent: true,
                opacity: 0.95
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            player.add(body);

            // Add cockpit (glass dome)
            const cockpitGeometry = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpitMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x66ccff,
                emissive: 0x0088cc,
                emissiveIntensity: 0.3,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.9, // Glass-like
                thickness: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.3, -0.2);
            cockpit.rotation.x = Math.PI;
            player.add(cockpit);

            // Add wings with more detailed geometry
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(0.8, -0.3);
            wingShape.lineTo(1.2, 0);
            wingShape.lineTo(0.8, 0.3);
            wingShape.lineTo(0, 0);

            const wingExtrudeSettings = {
                steps: 1,
                depth: 0.1,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05,
                bevelSegments: 3
            };

            const wingGeometry = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x2277cc,
                emissive: 0x001133,
                metalness: 0.7,
                roughness: 0.3,
                side: THREE.DoubleSide
            });

            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.6, 0, 0);
            leftWing.rotation.y = Math.PI / 2;
            leftWing.castShadow = true;
            player.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry.clone(), wingMaterial);
            rightWing.position.set(0.6, 0, 0);
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.castShadow = true;
            player.add(rightWing);

            // Add engine glow
            const engineGlowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
            engineGlow.position.set(0, 0, 0.9);
            engineGlow.scale.set(1, 1, 0.5); // Flatten into an ellipsoid
            player.add(engineGlow);

            // Add thruster effect (improved)
            const thrusterGeometry = new THREE.ConeGeometry(0.25, 0.7, 16);
            const thrusterMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.8
            });
            const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            thruster.position.set(0, 0, 1.1);
            thruster.rotation.x = Math.PI;
            player.add(thruster);

            // Add small details (antennas, etc.)
            const detailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const detailMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: 0.8,
                roughness: 0.2
            });

            const antenna1 = new THREE.Mesh(detailGeometry, detailMaterial);
            antenna1.position.set(0.3, 0.6, -0.2);
            antenna1.rotation.x = -Math.PI / 6;
            player.add(antenna1);

            const antenna2 = new THREE.Mesh(detailGeometry, detailMaterial);
            antenna2.position.set(-0.3, 0.6, -0.2);
            antenna2.rotation.x = -Math.PI / 6;
            player.add(antenna2);

            // Add player to scene
            scene.add(player);

            // Store original materials for effects
            player.userData = {
                originalMaterials: {
                    body: bodyMaterial,
                    wings: wingMaterial,
                    thruster: thrusterMaterial
                },
                enginePulse: 0
            };
        }

        // --- Update Player Position ---
        function updatePlayerPosition(isInitialPosition = false) {
            // Calculate position based on current lane and web type
            let x, y;

            if (webType === 'square') {
                // For square web, place player at the midpoint of each side
                switch (playerCurrentLaneIndex) {
                    case 0: // Top
                        x = 0;
                        y = WEB_RADIUS * 1.5;
                        break;
                    case 1: // Left
                        x = -WEB_RADIUS * 1.5;
                        y = 0;
                        break;
                    case 2: // Bottom
                        x = 0;
                        y = -WEB_RADIUS * 1.5;
                        break;
                    case 3: // Right
                        x = WEB_RADIUS * 1.5;
                        y = 0;
                        break;
                }
                // Rotation to face inward
                const angle = (playerCurrentLaneIndex * Math.PI / 2) + Math.PI / 2;
                playerTargetRotation = angle;
            }
            else if (webType === 'triangle') {
                // For triangle web, position at the three corners
                const angle = (playerCurrentLaneIndex * Math.PI * 2 / 3);
                const size = WEB_RADIUS * 1.8;
                if (playerCurrentLaneIndex === 0) {
                    x = 0;
                    y = size;
                } else if (playerCurrentLaneIndex === 1) {
                    x = -size;
                    y = -size/2;
                } else {
                    x = size;
                    y = -size/2;
                }
                playerTargetRotation = angle + Math.PI / 2;
            }
            else {
                // For circle or random polygon
                const angle = playerCurrentLaneIndex * LANE_ANGLE_STEP;
                x = WEB_RADIUS * Math.cos(angle);
                y = WEB_RADIUS * Math.sin(angle);
                playerTargetRotation = angle + Math.PI / 2;
            }

            player.position.set(x, y, PLAYER_Z);
            player.rotation.x = 0;

            // If this is the initial position, set rotation directly
            if (isInitialPosition) {
                player.rotation.z = playerTargetRotation;
            }
        }

        // --- Set Game Settings ---
        function setGameSettings(speed, directionSpeed, difficulty, web) {
            // Player Speed
            switch(speed) {
                case 'slow': playerLaneChangeRate = 30; break;
                case 'normal': playerLaneChangeRate = 20; break;
                case 'fast': playerLaneChangeRate = 12; break;
                default: playerLaneChangeRate = 20;
            }

            // Direction Movement Speed
            let rotationFactor;
            switch(directionSpeed) {
                case 'slow': rotationFactor = 0.05; break;
                case 'normal': rotationFactor = 0.1; break;
                case 'fast': rotationFactor = 0.2; break;
                default: rotationFactor = 0.1;
            }
            ROTATION_SMOOTHING_FACTOR = rotationFactor;

            // Difficulty
            switch(difficulty) {
                case 'easy':
                    currentEnemySpeed = 0.03;
                    currentEnemySpawnInterval = 80;
                    enemiesPerLevel = 15;
                    break;
                case 'medium':
                    currentEnemySpeed = 0.05;
                    currentEnemySpawnInterval = 50;
                    enemiesPerLevel = 20;
                    break;
                case 'hard':
                    currentEnemySpeed = 0.07;
                    currentEnemySpawnInterval = 30;
                    enemiesPerLevel = 25;
                    break;
                default:
                    currentEnemySpeed = 0.05;
                    currentEnemySpawnInterval = 50;
                    enemiesPerLevel = 20;
            }

            // Web Type
            webType = web;
        }

        // --- Start Game Function ---
        function startGame() {
            if (gameState === 'playing') return;

            // Get selected settings
            const selectedSpeed = speedSelect.value;
            const selectedDirectionSpeed = directionSpeedSelect.value;
            const selectedDifficulty = difficultySelect.value;
            const selectedWebType = webTypeSelect.value;

            setGameSettings(selectedSpeed, selectedDirectionSpeed, selectedDifficulty, selectedWebType);

            // Create the web based on selected type
            createWeb(selectedWebType);

            // Reset game state
            score = 0;
            lives = 3;
            level = 1;
            enemiesKilled = 0;
            enemiesRequired = enemiesPerLevel;
            enemySpawnTimer = 0;
            playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
            lastLaneChangeFrame = 0;
            activePowerUp = null;
            powerUpTimer = 0;

            // Clear existing game objects
            clearGameObjects();

            // Update player
            updatePlayerPosition(true);

            // Update UI
            updateScoreUI();
            updateLivesUI();
            updateLevelUI();
            updatePowerUpUI();

            uiElement.style.display = 'block';
            document.getElementById('power-ups').style.display = 'block';
            document.getElementById('level-indicator').style.display = 'block';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            menuElement.style.display = 'none';

            gameState = 'playing';
            isPaused = false;
            player.visible = true;
        }

        // --- Reset for Next Level ---
        function nextLevel() {
            if (gameState !== 'levelcomplete') return;

            // Increase level
            level++;

            // Increase difficulty
            currentEnemySpeed += 0.01;
            currentEnemySpawnInterval = Math.max(currentEnemySpawnInterval - 5, 20);
            enemiesRequired = Math.min(enemiesPerLevel + (level * 5), 50);

            // Reset level-specific variables
            enemiesKilled = 0;
            enemySpawnTimer = 0;

            // Choose a new random web shape for variety
            const webTypes = ['circle', 'square', 'triangle', 'random'];
            const newWebType = webTypes[Math.floor(Math.random() * webTypes.length)];
            createWeb(newWebType);

            // Reset player position after new web creation
            playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
            updatePlayerPosition(true);

            // Clear objects from previous level
            clearGameObjects();

            // Update UI
            updateLevelUI();

            // Hide level complete screen
            levelCompleteScreen.style.display = 'none';

            // Resume game
            gameState = 'playing';
            player.visible = true;
        }

        // --- Restart Game Function ---
        function restartGame() {
            gameState = 'menu';
            gameOverScreen.style.display = 'none';
            menuElement.style.display = 'block';
            uiElement.style.display = 'none';
            document.getElementById('power-ups').style.display = 'none';
            document.getElementById('level-indicator').style.display = 'none';

            player.visible = false;
            clearGameObjects();
        }

        // --- Clear all game objects ---
        function clearGameObjects() {
            // Remove all enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies.length = 0;

            // Remove all projectiles
            projectiles.forEach(p => scene.remove(p));
            projectiles.length = 0;

            // Remove all power-ups
            powerUps.forEach(p => scene.remove(p));
            powerUps.length = 0;

            // Remove all explosions
            explosions.forEach(e => scene.remove(e));
            explosions.length = 0;
        }

        // --- Create Standard Projectile ---
        function createProjectile(isSuperProjectile = false) {
            if (gameState !== 'playing' || isPaused) return;

            // Limit standard projectiles (unless super power active)
            if (!isSuperProjectile && !activePowerUp && projectiles.length > 5) return;

            const projectileGeometry = new THREE.BoxGeometry(0.3, 0.3, 2);

            // Different appearance for super projectiles
            const projectileMaterial = isSuperProjectile ?
                new THREE.MeshPhongMaterial({
                    color: 0xff00ff,
                    emissive: 0x880088,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                }) :
                new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0x888800,
                    emissiveIntensity: 0.3
                });

            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

            // Position at player
            projectile.position.copy(player.position);
            projectile.position.z -= 1.5;

            // Store projectile properties
            projectile.laneIndex = playerCurrentLaneIndex;
            projectile.isSuper = isSuperProjectile;

            scene.add(projectile);
            projectiles.push(projectile);

            // Play sound
            // sounds.fire.play();
        }

        // --- Create Enemy ---
        function createEnemy(isSpecial = false) {
            if (gameState !== 'playing' || isPaused) return;

            // Geometry based on enemy type
            const enemyGeometry = isSpecial ?
                new THREE.OctahedronGeometry(1.2) :
                new THREE.TetrahedronGeometry(1);

            // Material based on enemy type
            const enemyMaterial = isSpecial ?
                new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    emissive: 0x880000,
                    emissiveIntensity: 0.5,
                    shininess: 30
                }) :
                new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    emissive: 0x008800,
                    emissiveIntensity: 0.3,
                    shininess: 20
                });

            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

            // Random lane
            const laneIndex = Math.floor(Math.random() * NUM_LANES);

            // Position depends on web type
            let x, y;

            if (webType === 'square') {
                switch (laneIndex) {
                    case 0: // Top
                        x = 0;
                        y = WEB_RADIUS * 1.5;
                        break;
                    case 1: // Left
                        x = -WEB_RADIUS * 1.5;
                        y = 0;
                        break;
                    case 2: // Bottom
                        x = 0;
                        y = -WEB_RADIUS * 1.5;
                        break;
                    case 3: // Right
                        x = WEB_RADIUS * 1.5;
                        y = 0;
                        break;
                }
            }
            else if (webType === 'triangle') {
                const size = WEB_RADIUS * 1.8;
                if (laneIndex === 0) {
                    x = 0;
                    y = size;
                } else if (laneIndex === 1) {
                    x = -size;
                    y = -size/2;
                } else {
                    x = size;
                    y = -size/2;
                }
            }
            else {
                const angle = laneIndex * LANE_ANGLE_STEP;
                x = WEB_RADIUS * Math.cos(angle);
                y = WEB_RADIUS * Math.sin(angle);
            }

            enemy.position.set(x, y, ENEMY_START_Z);

            // Rotate enemy to face roughly towards the center
            if (webType === 'square' || webType === 'triangle') {
                const angle = (laneIndex * (Math.PI * 2) / NUM_LANES);
                enemy.rotation.z = angle;
            } else {
                const angle = laneIndex * LANE_ANGLE_STEP;
                enemy.rotation.z = angle;
            }

            // Add pulsating animation
            enemy.initialScale = isSpecial ? 1.2 : 1.0;
            enemy.pulsePhase = Math.random() * Math.PI * 2; // Random starting phase

            // Store enemy properties
            enemy.laneIndex = laneIndex;
            enemy.isSpecial = isSpecial;
            enemy.points = isSpecial ? 200 : 100;

            scene.add(enemy);
            enemies.push(enemy);
        }

        // --- Create Power-Up ---
        function createPowerUp(position) {
            const powerTypes = ['rapidFire', 'extraLife', 'shield', 'superProjectile'];
            const powerType = powerTypes[Math.floor(Math.random() * powerTypes.length)];

            // Create power-up object
            const powerGeometry = new THREE.SphereGeometry(0.8, 8, 8);

            // Color based on power-up type
            let powerColor;
            switch(powerType) {
                case 'rapidFire': powerColor = 0xffaa00; break; // Orange
                case 'extraLife': powerColor = 0xff0000; break; // Red
                case 'shield': powerColor = 0x0088ff; break; // Blue
                case 'superProjectile': powerColor = 0xff00ff; break; // Magenta
                default: powerColor = 0xffffff; // White
            }

            const powerMaterial = new THREE.MeshPhongMaterial({
                color: powerColor,
                emissive: powerColor,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9,
                shininess: 50
            });

            const powerUp = new THREE.Mesh(powerGeometry, powerMaterial);

            // Position at enemy death location (passed in as argument)
            powerUp.position.copy(position);

            // Store power-up properties
            powerUp.powerType = powerType;
            powerUp.rotationSpeed = 0.05;

            scene.add(powerUp);
            powerUps.push(powerUp);

            return powerUp;
        }

        // --- Create Enhanced Explosion Effect ---
        function createExplosion(position, color) {
            const baseColor = color || 0xffaa00;
            const particleCount = 30; // More particles for a denser effect
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);

            // Create initial flash
            const flashGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.scale.set(0.1, 0.1, 0.1);
            flash.userData = {
                life: 200,
                maxLife: 200,
                phase: 'expand' // expand, then fade
            };
            explosionGroup.add(flash);

            // Create shockwave ring
            const ringGeometry = new THREE.RingGeometry(0.2, 0.5, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: baseColor,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2; // Align with XZ plane
            ring.scale.set(0.1, 0.1, 0.1);
            ring.userData = {
                life: 400,
                maxLife: 400
            };
            explosionGroup.add(ring);

            // Create particles with different shapes for variety
            const geometries = [
                new THREE.TetrahedronGeometry(0.3, 0),
                new THREE.OctahedronGeometry(0.2, 0),
                new THREE.IcosahedronGeometry(0.2, 0),
                new THREE.SphereGeometry(0.15, 8, 8)
            ];

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                // Randomly select a geometry
                const particleGeometry = geometries[Math.floor(Math.random() * geometries.length)];

                // Create glowing material
                const particleMaterial = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    emissive: baseColor,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9,
                    metalness: 0.3,
                    roughness: 0.7
                });

                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                // Random initial position (closer to center)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = Math.random() * 0.3;

                particle.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );

                // Random velocity (faster and more varied)
                const speed = 0.1 + Math.random() * 0.3;
                particle.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );

                // Random rotation
                particle.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );

                // Random rotation velocity
                particle.rotationVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );

                // Lifespan in milliseconds (varied)
                particle.life = 300 + Math.random() * 700;
                particle.maxLife = particle.life;

                explosionGroup.add(particle);
            }

            // Add to scene
            scene.add(explosionGroup);
            explosions.push(explosionGroup);

            // Play explosion sound
            // sounds.explode.play();

            return explosionGroup;
        }

        // --- Apply Power-Up ---
        function applyPowerUp(powerType) {
            // Clear any existing power-up
            if (activePowerUp) {
                clearTimeout(powerUpTimer);
            }

            activePowerUp = powerType;
            updatePowerUpUI();

            // Apply power-up effect
            switch(powerType) {
                case 'rapidFire':
                    // Rapid fire handled in update loop
                    break;
                case 'extraLife':
                    lives++;
                    updateLivesUI();
                    activePowerUp = null; // Immediate effect
                    break;
                case 'shield':
                    // Shield is handled in collision detection
                    break;
                case 'superProjectile':
                    // Super projectiles handled in projectile creation and collision
                    break;
            }

            // Set timeout to clear power-up after duration (except extraLife which is immediate)
            if (powerType !== 'extraLife') {
                powerUpTimer = setTimeout(() => {
                    activePowerUp = null;
                    updatePowerUpUI();
                }, POWER_UP_DURATION);
            }

            // Play power-up sound
            // sounds.powerUp.play();
        }

        // --- Update Game State (per frame) ---
        function update(deltaTime) {
            if (gameState !== 'playing' || isPaused) {
                return;
            }

            const currentFrame = renderer.info.render.frame;

            // --- Animate Web ---
            if (webMesh) {
                webMesh.rotation.z += 0.0005; // Subtle rotation for visual effect
            }

            // --- Player Movement ---
            let laneChangeAttempt = false;
            let newLaneIndex = playerCurrentLaneIndex;

            if (keyState['ArrowLeft']) {
                newLaneIndex = (playerCurrentLaneIndex + 1) % NUM_LANES;
                laneChangeAttempt = true;
            } else if (keyState['ArrowRight']) {
                newLaneIndex = (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES;
                laneChangeAttempt = true;
            }

            if (laneChangeAttempt && currentFrame >= lastLaneChangeFrame + playerLaneChangeRate) {
                playerCurrentLaneIndex = newLaneIndex;
                updatePlayerPosition();
                lastLaneChangeFrame = currentFrame;
            }

            // Smooth rotation towards target rotation
            if (player.rotation.z !== playerTargetRotation) {
                // Calculate the shortest angle between current and target rotation
                let angleDiff = playerTargetRotation - player.rotation.z;

                // Ensure we rotate the shortest way (handle wrapping around 2π)
                if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                // Apply smoothing
                player.rotation.z += angleDiff * ROTATION_SMOOTHING_FACTOR;
            }

            // Handle automatic firing for rapid fire power-up
            if (activePowerUp === 'rapidFire' && currentFrame % 5 === 0) {
                createProjectile();
            }

            // --- Update Projectiles ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                projectile.position.z -= PROJECTILE_SPEED;

                // Super projectiles have a trailing effect
                if (projectile.isSuper && Math.random() > 0.5) {
                    const trailGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.5
                    });
                    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                    trail.position.copy(projectile.position);
                    scene.add(trail);

                    // Fade out trail
                    setTimeout(() => {
                        scene.remove(trail);
                        trail.geometry.dispose();
                        trail.material.dispose();
                    }, 500);
                }

                // Remove projectile if off screen
                if (projectile.position.z < ENEMY_START_Z - 5) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }

            // --- Update Enemies ---
            enemySpawnTimer++;

            // Spawn enemies until we've reached the level's required number
            if (enemySpawnTimer >= currentEnemySpawnInterval && enemies.length < enemiesRequired - enemiesKilled) {
                // Chance to spawn special enemy
                const isSpecial = Math.random() < SPECIAL_ENEMY_CHANCE;
                createEnemy(isSpecial);
                enemySpawnTimer = 0;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Move enemy
                enemy.position.z += currentEnemySpeed * (enemy.isSpecial ? 1.2 : 1.0);

                // Pulsating animation
                const pulseScale = enemy.initialScale + Math.sin(enemy.pulsePhase) * 0.1;
                enemy.pulsePhase += 0.05;
                enemy.scale.set(pulseScale, pulseScale, pulseScale);

                // Special enemies also rotate
                if (enemy.isSpecial) {
                    enemy.rotation.y += 0.03;
                    enemy.rotation.x += 0.02;
                }

                // Check if enemy reached the player's end
                if (enemy.position.z > ENEMY_END_Z) {
                    // Player loses a life if not shielded
                    if (activePowerUp !== 'shield') {
                        loseLife();
                    } else {
                        // Shield absorbs one hit
                        activePowerUp = null;
                        updatePowerUpUI();
                        clearTimeout(powerUpTimer);

                        // Visual effect for shield hit
                        createExplosion(enemy.position, 0x0088ff);
                    }

                    scene.remove(enemy);
                    enemies.splice(i, 1);

                    if (gameState !== 'playing') return;
                }
            }

            // --- Update Power-Ups ---
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];

                // Move power-up towards player
                powerUp.position.z += currentEnemySpeed * 0.5;

                // Rotate power-up
                powerUp.rotation.y += powerUp.rotationSpeed;
                powerUp.rotation.x += powerUp.rotationSpeed * 0.7;

                // Pulsate size
                const pulseScale = 1 + 0.1 * Math.sin(performance.now() * 0.005);
                powerUp.scale.set(pulseScale, pulseScale, pulseScale);

                // Check if power-up is collected
                if (powerUp.position.z > PLAYER_Z - 1 &&
                    Math.abs(powerUp.position.x - player.position.x) < 2 &&
                    Math.abs(powerUp.position.y - player.position.y) < 2) {

                    // Collect power-up
                    applyPowerUp(powerUp.powerType);

                    // Remove power-up
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }

                // Remove if past player
                if (powerUp.position.z > PLAYER_Z + 5) {
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }

            // --- Update Explosions ---
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                let removeExplosion = true;

                // Update each child of the explosion group
                explosion.children.forEach(child => {
                    // Handle the initial flash
                    if (child.userData && child.userData.phase === 'expand') {
                        // Flash expands quickly then fades
                        if (child.userData.life > child.userData.maxLife * 0.7) {
                            // Expand phase
                            const expandRatio = 1 - ((child.userData.life - child.userData.maxLife * 0.7) / (child.userData.maxLife * 0.3));
                            const scale = 0.1 + expandRatio * 2.0;
                            child.scale.set(scale, scale, scale);
                        } else {
                            // Fade phase
                            child.userData.phase = 'fade';
                        }
                    }

                    // Handle the shockwave ring
                    if (child.geometry instanceof THREE.RingGeometry) {
                        const lifeRatio = child.userData.life / child.userData.maxLife;
                        // Expand the ring
                        const scale = 0.1 + (1 - lifeRatio) * 5.0;
                        child.scale.set(scale, scale, scale);
                        // Fade the ring
                        child.material.opacity = lifeRatio * 0.7;
                    }

                    // Update standard particles
                    if (child.velocity) {
                        // Update position
                        child.position.add(child.velocity);

                        // Update rotation if it has rotation velocity
                        if (child.rotationVelocity) {
                            child.rotation.x += child.rotationVelocity.x;
                            child.rotation.y += child.rotationVelocity.y;
                            child.rotation.z += child.rotationVelocity.z;
                        }

                        // Slow down particles over time (drag)
                        child.velocity.multiplyScalar(0.98);
                    }

                    // Update life for all children
                    if (child.userData && child.userData.life !== undefined) {
                        child.userData.life -= deltaTime;

                        // Fade out based on life
                        if (child.userData.life > 0) {
                            const lifeRatio = child.userData.life / child.userData.maxLife;
                            child.material.opacity = lifeRatio * (child.userData.phase === 'fade' ? 0.8 : 0.9);
                            removeExplosion = false;
                        } else {
                            child.material.opacity = 0;
                        }
                    }
                });

                // Remove explosion if all particles are dead
                if (removeExplosion) {
                    // Clean up all children
                    explosion.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    scene.remove(explosion);
                    explosions.splice(i, 1);
                }
            }

            // --- Collision Detection (Projectile vs Enemy) ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                let projectileHit = false;

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];

                    // Check if in same lane and close enough on Z axis
                    if (projectile.laneIndex === enemy.laneIndex &&
                        Math.abs(projectile.position.z - enemy.position.z) < COLLISION_Z_TOLERANCE) {

                        // Collision detected!
                        const hitPoints = enemy.points;
                        addScore(hitPoints);
                        enemiesKilled++;

                        // Create explosion effect
                        createExplosion(enemy.position, enemy.isSpecial ? 0xff0000 : 0x00ff00);

                        // Chance to spawn power-up
                        if (Math.random() < POWER_UP_CHANCE || enemy.isSpecial) {
                            createPowerUp(enemy.position);
                        }

                        // Remove enemy
                        scene.remove(enemy);
                        enemies.splice(j, 1);

                        // Super projectiles can pass through enemies
                        if (!projectile.isSuper) {
                            // Remove projectile
                            scene.remove(projectile);
                            projectiles.splice(i, 1);
                            projectileHit = true;
                        }

                        // Check if level is complete
                        if (enemiesKilled >= enemiesRequired) {
                            completedLevel();
                        }

                        // Break inner loop if projectile was destroyed
                        if (projectileHit) break;
                    }
                }
            }
        }

        // --- Game Over Logic ---
        function loseLife() {
            if (gameState !== 'playing') return;

            lives--;
            updateLivesUI();

            // Visual indication
            createExplosion(player.position, 0xff0000);

            // Make player flash
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                player.visible = !player.visible;
                flashCount++;
                if (flashCount >= 6) {
                    clearInterval(flashInterval);
                    player.visible = true;
                }
            }, 200);

            if (lives <= 0) {
                endGame();
            }
        }

        function endGame() {
            if (gameState !== 'playing') return;

            gameState = 'gameover';
            finalScoreUI.textContent = 'FINAL SCORE: ' + score;
            gameOverScreen.style.display = 'block';
            uiElement.style.display = 'none';
            document.getElementById('power-ups').style.display = 'none';
            document.getElementById('level-indicator').style.display = 'none';

            // Clear game objects
            clearGameObjects();

            // Hide player
            player.visible = false;

            // Clear power-up timer
            if (activePowerUp) {
                clearTimeout(powerUpTimer);
                activePowerUp = null;
            }
        }

        // --- Level Complete Logic ---
        function completedLevel() {
            if (gameState !== 'playing') return;

            gameState = 'levelcomplete';
            levelScoreUI.textContent = 'LEVEL ' + level + ' SCORE: ' + score;
            levelCompleteScreen.style.display = 'block';

            // Bonus points for completing level
            const levelBonus = level * 500;
            addScore(levelBonus);

            // Play level complete sound
            // sounds.levelComplete.play();

            // Clear power-up timer
            if (activePowerUp) {
                clearTimeout(powerUpTimer);
                activePowerUp = null;
            }

            // Hide player
            player.visible = false;
        }

        // --- UI Updates ---
        function addScore(points) {
            score += points;
            updateScoreUI();
        }

        function updateScoreUI() {
            scoreUI.textContent = 'SCORE: ' + score;
        }

        function updateLivesUI() {
            livesUI.textContent = 'LIVES: ' + lives;
        }

        function updateLevelUI() {
            levelUI.textContent = 'LEVEL: ' + level;
        }

        function updatePowerUpUI() {
            let powerText = 'POWER: ';

            switch(activePowerUp) {
                case 'rapidFire': powerText += 'RAPID FIRE'; break;
                case 'shield': powerText += 'SHIELD'; break;
                case 'superProjectile': powerText += 'SUPER SHOT'; break;
                default: powerText += 'NONE';
            }

            powerUpUI.textContent = powerText;
        }

        // --- Create Player Trail Particle ---
        function createPlayerTrailParticle() {
            if (!player.visible || gameState !== 'playing') return;

            // Create a particle at the player's thruster position
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // Position at player's thruster
            const thrusterPosition = new THREE.Vector3(0, 0, 1.1);
            thrusterPosition.applyMatrix4(player.matrixWorld);
            particle.position.copy(thrusterPosition);

            // Add some random variation
            particle.position.x += (Math.random() - 0.5) * 0.2;
            particle.position.y += (Math.random() - 0.5) * 0.2;
            particle.position.z += (Math.random() - 0.5) * 0.2;

            // Set particle properties
            particle.scale.set(
                0.5 + Math.random() * 0.5,
                0.5 + Math.random() * 0.5,
                0.5 + Math.random() * 0.5
            );

            particle.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    0.05 + Math.random() * 0.05
                ),
                life: 1000, // milliseconds
                maxLife: 1000
            };

            scene.add(particle);
            playerTrailParticles.push(particle);

            return particle;
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Calculate delta time
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            // Animate starfield (twinkling effect)
            if (starfield && starfield.material.uniforms) {
                starfield.material.uniforms.time.value = currentTime;
                starfield.rotation.y += 0.0001; // Very slow rotation
            }

            // Animate web
            if (webMesh && webMesh.userData) {
                // Pulse the fill opacity
                const fillMesh = webMesh.userData.fillMesh;
                if (fillMesh) {
                    webMesh.userData.pulsePhase += 0.02;
                    const pulseValue = Math.sin(webMesh.userData.pulsePhase) * 0.5 + 0.5;
                    fillMesh.material.opacity = 0.1 + pulseValue * 0.1;

                    // Subtle rotation
                    webMesh.rotation.z += 0.0003;
                }
            }

            // Animate center light
            const centerLight = scene.children.find(child =>
                child instanceof THREE.PointLight && child.position.x === 0 &&
                child.position.y === 0 && child.position.z === 0);

            if (centerLight && centerLight.userData) {
                centerLight.userData.pulsePhase += 0.05;
                const pulseValue = Math.sin(centerLight.userData.pulsePhase) * 0.5 + 0.5;
                centerLight.intensity = 0.5 + pulseValue * 0.5;
            }

            // Animate player engine glow
            if (player.visible && player.userData) {
                player.userData.enginePulse += 0.1;
                const pulseValue = Math.sin(player.userData.enginePulse) * 0.5 + 0.5;

                // Find engine glow (sphere at back of player)
                player.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry &&
                        child.position.z > 0.5) {
                        child.scale.set(1 + pulseValue * 0.2, 1 + pulseValue * 0.2, 0.5);
                        child.material.opacity = 0.6 + pulseValue * 0.4;
                    }
                });

                // Create trail particles occasionally
                if (gameState === 'playing' && Math.random() > 0.7) {
                    createPlayerTrailParticle();
                }
            }

            // Update player trail particles
            for (let i = playerTrailParticles.length - 1; i >= 0; i--) {
                const particle = playerTrailParticles[i];

                // Update position
                particle.position.add(particle.userData.velocity);

                // Update life and scale/opacity
                particle.userData.life -= deltaTime;
                const lifeRatio = particle.userData.life / particle.userData.maxLife;

                if (lifeRatio > 0) {
                    particle.scale.multiplyScalar(0.98);
                    particle.material.opacity = lifeRatio * 0.7;
                } else {
                    // Remove dead particles
                    scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                    playerTrailParticles.splice(i, 1);
                }
            }

            // Update game state
            if (!isPaused) {
                update(deltaTime);
            }

            // Render with post-processing if available
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            keyState[event.key] = true;

            // Handle firing
            if (gameState === 'playing' && event.key === ' ') {
                // Create super projectile if power-up is active
                createProjectile(activePowerUp === 'superProjectile');
            }

            // Toggle pause
            if (gameState === 'playing' && event.key === 'p') {
                isPaused = !isPaused;
                pauseScreen.style.display = isPaused ? 'block' : 'none';
            }

            // Prevent scrolling when pressing space or arrow keys
            if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
            }
        }

        function onKeyUp(event) {
            keyState[event.key] = false;
        }

        // --- Start the Game ---
        init();
    </script>
</body>
</html>
