<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Tempest 80s Clone (Three.js)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #00ff00;
            font-family: 'Press Start 2P', cursive;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }

        /* Shared styles for UI and Menu */
        #ui, #game-over, #menu, #level-complete {
            position: absolute;
            /*z-index: 100;*/
            pointer-events: none;
            text-shadow: 0 0 5px;
            font-size: 1em;
        }

        #ui {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            /*max-width: 600px;*/
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            display: flex;
            flex-direction: column;
            gap: 5px;
            /*background-color: rgba(0, 0, 0, 0.8);*/
            /*border: 2px solid #00ffff;*/
            /*border-radius: 8px;*/
            /*padding: 8px;*/
            /*box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.2);*/
            position: relative;
            z-index: 200;
        }

        #ui:before {
            content: "TEMPESTO";
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #000;
            padding: 0 10px;
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .ui-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 3px 0;
            /*border-bottom: 1px solid rgba(0, 255, 255, 0.3);*/
        }

        #ui-row:last-child {
            border-bottom: none;
        }

        #score, #high-score {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            padding: 3px 6px;
            background-color: rgba(255, 255, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.2);
            letter-spacing: 1px;
        }

        #lives, #bombs {
            color: #ff5555;
            text-shadow: 0 0 8px #ff0000;
            padding: 3px 6px;
            background-color: rgba(255, 0, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.2);
            letter-spacing: 0px;
        }

        #enemies-remaining {
            color: #55ff55;
            text-shadow: 0 0 8px #00ff00;
            padding: 3px 6px;
            background-color: rgba(0, 255, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
            letter-spacing: 0px;
        }

        #power-ups #active-power {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            padding: 3px 6px;
            background-color: rgba(255, 0, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 0, 255, 0.2);
            letter-spacing: 0px;
        }

        #level-indicator #current-level {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            padding: 3px 6px;
            background-color: rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.2);
            letter-spacing: 0px;
            font-size: 1em;
            font-weight: bold;
            display: inline-block;
        }

        #game-over, #level-complete {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: all;
        }

        #game-over {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        #level-complete {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #game-over h1, #level-complete h1 {
            margin: 0 0 15px 0;
            font-size: 2.5em;
        }

        #game-over #final-score, #level-complete #level-score {
            margin-bottom: 20px;
        }

        #menu {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffff00;
            padding: 30px;
            text-align: center;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
            pointer-events: all;
            max-width: 90%;
            width: 400px;
            box-sizing: border-box;
        }

        #menu h1 {
            margin: 0 0 20px 0;
            font-size: 1.8em;
            text-shadow: 0 0 10px #ffff00;
        }

        #menu div {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #menu label {
            margin-right: 10px;
            white-space: nowrap;
        }

        #menu select, #menu button, #game-over button, #level-complete button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #000;
            color: #ffff00;
            border: 2px solid #ffff00;
            text-shadow: 0 0 5px #ffff00;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            border-radius: 0;
            min-width: 100px;
        }

        #menu select option {
            background-color: #000;
            color: #ffff00;
        }

        #menu button, #game-over button, #level-complete button {
            width: 100%;
            margin-top: 10px;
        }

        #menu button:hover, #game-over button:hover, #level-complete button:hover {
            text-shadow: 0 0 15px #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        /* Power-up indicator */
        #power-ups {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            font-weight: bold;
        }

        /* Level indicator */
        #level-indicator {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Pause screen */
        #pause-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff;
            font-size: 2em;
            display: none;
            z-index: 101;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.6em;
            z-index: 100;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>

<div id="pause-screen">PAUSED</div>

<div id="instructions">
    ARROWS: MOVE | SPACE: FIRE | B: BOMB | P/ENTER: PAUSE | MOUSE: ROTATE TUNNEL | CLICK: TOGGLE ROTATION | AI: AUTO
    PLAY | AUTO MODE: CONTINUOUS LEARNING
</div>

<div id="game-over">
    <h1>GAME OVER</h1>
    <div id="final-score"></div>
    <div id="final-high-score"></div>
    <div id="ai-restart-countdown" style="display: none; margin-bottom: 10px; color: #ffff00;">
        AUTO RESTART IN: <span id="countdown-value">10</span>
    </div>
    <button id="restart-button">RESTART</button>
</div>

<div id="level-complete">
    <h1>LEVEL COMPLETE</h1>
    <div id="level-score"></div>
    <div id="level-high-score"></div>
    <button id="next-level-button">NEXT LEVEL</button>
</div>

<div id="menu">
    <h1>TEMPEST CLONE</h1>
    <div>
        <label for="speed-select">PLAYER SPEED:</label>
        <select id="speed-select">
            <option value="slow">SLOW</option>
            <option value="normal" selected>NORMAL</option>
            <option value="fast">FAST</option>
        </select>
    </div>
    <div>
        <label for="difficulty-select">DIFFICULTY:</label>
        <select id="difficulty-select">
            <option value="easy">EASY</option>
            <option value="medium" selected>MEDIUM</option>
            <option value="hard">HARD</option>
        </select>
    </div>
    <div>
        <label for="web-type-select">WEB TYPE:</label>
        <select id="web-type-select">
            <option value="circle" selected>CIRCLE</option>
            <option value="square">SQUARE</option>
            <option value="triangle">TRIANGLE</option>
            <option value="pentagon">PENTAGON</option>
            <option value="hexagon">HEXAGON</option>
            <option value="octagon">OCTAGON</option>
            <option value="random">RANDOM</option>
        </select>
    </div>
    <div>
        <label for="tube-width-select">TUBE WIDTH:</label>
        <select id="tube-width-select">
            <option value="wire">WIRE</option>
            <option value="small">SMALL</option>
            <option value="medium" selected>MEDIUM</option>
            <option value="large">LARGE</option>
        </select>
    </div>
    <div>
        <label for="lives-select">LIVES:</label>
        <select id="lives-select">
            <option value="3" selected>3</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
        </select>
    </div>
    <div>
        <label for="ai-player-select">AI PLAYER:</label>
        <select id="ai-player-select">
            <option value="off" selected>OFF</option>
            <option value="on">ON</option>
            <option value="auto">AUTO</option>
        </select>
    </div>
    <div id="ai-learning-options"
         style="display: none; flex-direction: column; align-items: stretch; margin-top: 10px;">
        <div id="ai-auto-mode-indicator"
             style="text-align: center; margin-bottom: 10px; color: #ff0000; display: none;">
            AUTO MODE: AI WILL PLAY CONTINUOUSLY
        </div>
        <div style="text-align: left; margin-bottom: 5px;">
            <span>EPISODES: <span id="ai-episodes">0</span></span>
        </div>
        <div style="text-align: left; margin-bottom: 5px;">
            <span>TOTAL REWARD: <span id="ai-reward">0</span></span>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <label for="ai-learning-rate">LEARNING RATE:</label>
            <select id="ai-learning-rate">
                <option value="0.05">LOW (0.05)</option>
                <option value="0.1" selected>MEDIUM (0.1)</option>
                <option value="0.2">HIGH (0.2)</option>
            </select>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <label for="ai-exploration-rate">EXPLORATION:</label>
            <select id="ai-exploration-rate">
                <option value="0.1">LOW (0.1)</option>
                <option value="0.2" selected>MEDIUM (0.2)</option>
                <option value="0.3">HIGH (0.3)</option>
            </select>
        </div>
        <button id="ai-reset-button" style="margin-top: 5px;">RESET AI LEARNING</button>
    </div>
    <button id="start-button">START GAME</button>
</div>

<div id="ui" style="display: none">
    <div class="ui-row">
        <div id="score">SCORE: 0</div>
        <div id="high-score">HIGH SCORE: 0</div>
    </div>
    <div class="ui-row">
        <div id="lives">LIVES: 3</div>
        <div id="enemies-remaining">ENEMIES: 0/0</div>
    </div>
    <div class="ui-row">
        <div id="bombs">BOMBS: 3</div>
        <div id="power-ups">
            <div id="active-power">POWER: NONE</div>
        </div>
    </div>
    <div class="ui-row" style="align-items: center;">
        <div id="level-indicator">
            <div id="current-level">LEVEL: 1</div>
        </div>
    </div>
</div>

<!-- Include Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- Global Variables ---
    let scene, camera, renderer;
    let webMesh;
    let player;
    const projectiles = [];
    const enemies = [];
    const powerUps = [];
    const explosions = [];
    const keyState = {};

    // AI player variables
    let isAIEnabled = false;
    let isAIAutoMode = false; // Flag for auto mode (continuous learning)
    let aiDecisionTimer = 0;
    const AI_DECISION_INTERVAL = 10; // Make decisions every 10 frames

    // AI learning variables
    let aiLearning = {
        qTable: {}, // State-action value function
        learningRate: 0.1, // Alpha - how much to update Q-values
        discountFactor: 0.9, // Gamma - importance of future rewards
        explorationRate: 0.2, // Epsilon - probability of random action
        lastState: null, // Previous state
        lastAction: null, // Previous action
        cumulativeReward: 0, // Total reward accumulated
        episodeCount: 0, // Number of games played
        initialized: false // Whether the Q-table has been loaded
    };

    // localStorage keys for AI learning
    const STORAGE_KEY_Q_TABLE = 'tempest3d_qTable';
    const STORAGE_KEY_AI_STATS = 'tempest3d_aiStats';

    // Mouse tracking variables
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;
    let isRotationEnabled = true; // Flag to enable/disable tunnel rotation

    // localStorage keys
    const STORAGE_KEY_ROTATION_X = 'tempest3d_rotationX';
    const STORAGE_KEY_ROTATION_Y = 'tempest3d_rotationY';
    const STORAGE_KEY_ROTATION_ENABLED = 'tempest3d_rotationEnabled';
    const STORAGE_KEY_HIGH_SCORE = 'tempest3d_highScore';

    // Debounce timer for saving rotation state
    let saveRotationTimer = null;

    // Game State
    let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameover', 'levelcomplete'
    let isPaused = false;

    // AI auto-restart variables
    let aiRestartCountdown = 10; // 10 second countdown
    let aiRestartCountdownInterval = null;

    // Web Configuration
    let NUM_LANES = 16;
    const WEB_DEPTH = 100;
    const WEB_RADIUS = 8;
    let LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;
    let webType = 'circle';
    let tubeWidth = 'medium'; // Options: 'wire', 'small', 'medium', 'large'

    // Fixed Z positions
    const PLAYER_Z = WEB_DEPTH / 2;
    const ENEMY_START_Z = -WEB_DEPTH / 2 + 1;
    const ENEMY_END_Z = WEB_DEPTH / 2 - 2;

    // Game mechanics
    const PROJECTILE_SPEED = 0.6;
    const COLLISION_Z_TOLERANCE = 1.0;
    const POWER_UP_CHANCE = 0.15; // 15% chance of power-up spawn per enemy kill
    const POWER_UP_DURATION = 10000; // 10 seconds
    const SPECIAL_ENEMY_CHANCE = 0.1; // 10% chance of special enemy
    const BOMB_POINTS = 3000;
    // Configurable Settings
    let playerLaneChangeRate = 6;
    let currentEnemySpeed = 0.05;
    let currentEnemySpawnInterval = 50;
    let enemiesPerLevel = 20;

    // Game stats
    let score = 0;
    let highScore = 0;
    let lives = 3;
    let level = 1;
    let enemiesKilled = 0;
    let enemiesRequired = enemiesPerLevel;
    let enemySpawnTimer = 0;
    let playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
    let lastLaneChangeFrame = 0;
    let activePowerUp = null;
    let powerUpTimer = 0;
    let lastFrameTime = 0;

    // Bomb variables
    let bombs = 0; // Start with 3 bombs
    let lastBombMilestone = 0; // Track the last score milestone for bomb rewards

    // Sound effects (placeholders)
    const sounds = {
        fire: new Audio(),
        explode: new Audio(),
        powerUp: new Audio(),
        levelComplete: new Audio()
    };

    // --- UI Elements ---
    const uiElement = document.getElementById('ui');
    const scoreUI = document.getElementById('score');
    const highScoreUI = document.getElementById('high-score');
    const livesUI = document.getElementById('lives');
    const enemiesRemainingUI = document.getElementById('enemies-remaining');
    const bombsUI = document.getElementById('bombs');
    const powerUpUI = document.getElementById('active-power');
    const levelUI = document.getElementById('current-level');
    const pauseScreen = document.getElementById('pause-screen');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreUI = document.getElementById('final-score');
    const finalHighScoreUI = document.getElementById('final-high-score');
    const restartButton = document.getElementById('restart-button');
    const levelCompleteScreen = document.getElementById('level-complete');
    const levelScoreUI = document.getElementById('level-score');
    const levelHighScoreUI = document.getElementById('level-high-score');
    const nextLevelButton = document.getElementById('next-level-button');
    const menuElement = document.getElementById('menu');
    const speedSelect = document.getElementById('speed-select');
    const difficultySelect = document.getElementById('difficulty-select');
    const webTypeSelect = document.getElementById('web-type-select');
    const tubeWidthSelect = document.getElementById('tube-width-select');
    const livesSelect = document.getElementById('lives-select');
    const aiPlayerSelect = document.getElementById('ai-player-select');
    const startButton = document.getElementById('start-button');

    // AI auto-restart UI elements
    const aiRestartCountdownUI = document.getElementById('ai-restart-countdown');
    const countdownValueUI = document.getElementById('countdown-value');

    // AI learning UI elements
    const aiLearningOptions = document.getElementById('ai-learning-options');
    const aiAutoModeIndicator = document.getElementById('ai-auto-mode-indicator');
    const aiEpisodesDisplay = document.getElementById('ai-episodes');
    const aiRewardDisplay = document.getElementById('ai-reward');
    const aiLearningRateSelect = document.getElementById('ai-learning-rate');
    const aiExplorationRateSelect = document.getElementById('ai-exploration-rate');
    const aiResetButton = document.getElementById('ai-reset-button');

    // --- Save and Load Rotation State ---
    function saveRotationState() {
        try {
            localStorage.setItem(STORAGE_KEY_ROTATION_X, targetRotationX);
            localStorage.setItem(STORAGE_KEY_ROTATION_Y, targetRotationY);
            localStorage.setItem(STORAGE_KEY_ROTATION_ENABLED, isRotationEnabled);
        } catch (e) {
            console.error("Failed to save rotation state to localStorage:", e);
        }
    }

    function loadRotationState() {
        try {
            const savedRotationX = localStorage.getItem(STORAGE_KEY_ROTATION_X);
            const savedRotationY = localStorage.getItem(STORAGE_KEY_ROTATION_Y);
            const savedRotationEnabled = localStorage.getItem(STORAGE_KEY_ROTATION_ENABLED);

            if (savedRotationX !== null) {
                targetRotationX = parseFloat(savedRotationX);
            }

            if (savedRotationY !== null) {
                targetRotationY = parseFloat(savedRotationY);
            }

            if (savedRotationEnabled !== null) {
                isRotationEnabled = savedRotationEnabled === 'true';
            }
        } catch (e) {
            console.error("Failed to load rotation state from localStorage:", e);
        }
    }

    // --- Save and Load High Score ---
    function saveHighScore() {
        try {
            localStorage.setItem(STORAGE_KEY_HIGH_SCORE, highScore);
        } catch (e) {
            console.error("Failed to save high score to localStorage:", e);
        }
    }

    function loadHighScore() {
        try {
            const savedHighScore = localStorage.getItem(STORAGE_KEY_HIGH_SCORE);

            if (savedHighScore !== null) {
                highScore = parseInt(savedHighScore);
                updateHighScoreUI();
            }
        } catch (e) {
            console.error("Failed to load high score from localStorage:", e);
        }
    }

    // --- Initialization Function ---
    function init() {
        // Load saved rotation state
        loadRotationState();

        // Load high score
        loadHighScore();

        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera setup
        camera = new THREE.PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
//        camera.position.set(0, 8, WEB_DEPTH / 2 + 10);
        camera.position.set(0, .6, WEB_DEPTH / 2 + 15);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting to enhance 3D effects
        addLighting();

        // Create the initial web - it will be recreated with startGame
        createWeb(webType);

        // Create player
        createPlayer();
        player.visible = false;

        // Initial state: show menu, hide game UI/game over
        uiElement.style.display = 'none';
        document.getElementById('power-ups').style.display = 'none';
        document.getElementById('level-indicator').style.display = 'none';
        gameOverScreen.style.display = 'none';
        levelCompleteScreen.style.display = 'none';
        menuElement.style.display = 'block';
        document.getElementById('instructions').style.display = 'block';

        // Event Listeners
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);

        // Button listeners
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
        nextLevelButton.addEventListener('click', nextLevel);

        // AI learning listeners
        aiPlayerSelect.addEventListener('change', toggleAILearningOptions);
        aiLearningRateSelect.addEventListener('change', function () {
            aiLearning.learningRate = parseFloat(this.value);
            saveAILearningData();
        });
        aiExplorationRateSelect.addEventListener('change', function () {
            aiLearning.explorationRate = parseFloat(this.value);
            saveAILearningData();
        });
        aiResetButton.addEventListener('click', resetAILearningData);

        // Initialize AI learning options visibility
        toggleAILearningOptions();

        // Start the animation loop
        lastFrameTime = performance.now();
        animate();
    }

    // --- Add scene lighting ---
    function addLighting() {
        // Add ambient light for base illumination
        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);

        // Add directional light for shadows and depth
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);

        // Add point light at camera position for dynamic lighting
        const pointLight = new THREE.PointLight(0x0088ff, 0.8, 50);
        pointLight.position.copy(camera.position);
        scene.add(pointLight);
    }

    // --- Create Web Geometry based on selected type ---
    function createWeb(type) {
        // Remove existing web if any
        if (webMesh) {
            scene.remove(webMesh);
        }

        let shape;
        webType = type;

        switch (type) {
            case 'square':
                shape = createSquareWeb();
                NUM_LANES = 4; // 4 sides
                break;
            case 'triangle':
                shape = createTriangleWeb();
                NUM_LANES = 3; // 3 sides
                break;
            case 'pentagon':
                NUM_LANES = 5; // 5 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'hexagon':
                NUM_LANES = 6; // 6 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'octagon':
                NUM_LANES = 8; // 8 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'random':
                // Create a random polygon between 5 and 8 sides
                NUM_LANES = Math.floor(Math.random() * 4) + 5; // 5 to 8 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'circle':
            default:
                // Circle-like polygon with 16 sides
                NUM_LANES = 16;
                shape = createPolygonWeb(NUM_LANES);
                break;
        }

        // Update LANE_ANGLE_STEP based on NUM_LANES
        LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;

        const extrudeSettings = {
            steps: 1,
            depth: WEB_DEPTH,
            bevelEnabled: false
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.translate(0, 0, -WEB_DEPTH / 2);

        // Create enhanced wireframe with tube-like effect
        const edges = new THREE.EdgesGeometry(geometry);

        // Create a group to hold all tube segments
        webMesh = new THREE.Group();

        // Get the positions from the edges geometry
        const positions = edges.attributes.position.array;

        // Create tube segments for each edge
        for (let i = 0; i < positions.length; i += 6) {
            // Each edge has two vertices (start and end)
            const startPoint = new THREE.Vector3(
              positions[i], positions[i + 1], positions[i + 2]
            );
            const endPoint = new THREE.Vector3(
              positions[i + 3], positions[i + 4], positions[i + 5]
            );

            // Create a path for the tube
            const path = new THREE.CatmullRomCurve3([startPoint, endPoint]);

            // Create tube geometry with radius proportional to web size and selected width
            let tubeRadiusMultiplier;
            switch (tubeWidth) {
                case 'wire':
                    tubeRadiusMultiplier = 0.0005;
                    break; // 0.5% of web radius
                case 'small':
                    tubeRadiusMultiplier = 0.001;
                    break; // 1% of web radius
                case 'medium':
                    tubeRadiusMultiplier = 0.002;
                    break; // 2% of web radius (default)
                case 'large':
                    tubeRadiusMultiplier = 0.004;
                    break; // 4% of web radius
                default:
                    tubeRadiusMultiplier = 0.02; // Default to medium
            }
            const tubeRadius = WEB_RADIUS * tubeRadiusMultiplier;
            const tubeGeometry = new THREE.TubeGeometry(
              path,
              1,              // tubularSegments
              tubeRadius,     // radius
              8,              // radialSegments
              false           // closed
            );

            // Create material with glow effect
            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8,
                shininess: 30
            });

            // Create mesh and add to group
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            webMesh.add(tubeMesh);
        }

        // Apply saved rotation values if available, otherwise use neutral position
        if (targetRotationX !== 0 || targetRotationY !== 0) {
            webMesh.rotation.x = targetRotationX;
            webMesh.rotation.y = targetRotationY;
        } else {
            webMesh.rotation.x = 0;
            webMesh.rotation.y = 0;
        }

        scene.add(webMesh);
    }

    // Helper functions to create different web shapes
    function createPolygonWeb(sides) {
        const shape = new THREE.Shape();
        shape.moveTo(WEB_RADIUS, 0);
        for (let i = 1; i <= sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            shape.lineTo(WEB_RADIUS * Math.cos(angle), WEB_RADIUS * Math.sin(angle));
        }
        return shape;
    }

    function createSquareWeb() {
        const shape = new THREE.Shape();
        const size = WEB_RADIUS * 1.5;
        shape.moveTo(size, size);
        shape.lineTo(-size, size);
        shape.lineTo(-size, -size);
        shape.lineTo(size, -size);
        shape.lineTo(size, size);
        return shape;
    }

    function createTriangleWeb() {
        const shape = new THREE.Shape();
        const size = WEB_RADIUS * 1.8;
        shape.moveTo(0, size);
        shape.lineTo(-size, -size / 2);
        shape.lineTo(size, -size / 2);
        shape.lineTo(0, size);
        return shape;
    }

    // --- Create Player with enhanced visuals ---
    function createPlayer() {
        // Remove existing player if any
        if (player) {
            scene.remove(player);
        }

        // Create a group to hold player elements
        player = new THREE.Group();

        // Main body (box)
        const bodyGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0x440000,
            shininess: 30,
            transparent: true,
            opacity: 0.9
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        player.add(body);

        // Add wings to make it look more like a spaceship
        const wingGeometry = new THREE.ConeGeometry(0.4, 1, 4);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xffaa00,
            emissive: 0x441100,
            shininess: 20
        });

        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.8, 0, 0);
        leftWing.rotation.z = Math.PI / 2;
        player.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.8, 0, 0);
        rightWing.rotation.z = -Math.PI / 2;
        player.add(rightWing);

        // Add thruster effect (simple cone)
        const thrusterGeometry = new THREE.ConeGeometry(0.3, 0.6, 8);
        const thrusterMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x00aaff,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
        });
        const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
        thruster.position.set(0, 0, 0.9);
        thruster.rotation.x = Math.PI;
        player.add(thruster);

        scene.add(player);
    }

    // --- Update Player Position ---
    function updatePlayerPosition() {
        // Calculate position based on current lane and web type
        let x, y;
        let angle;

        if (webType === 'square') {
            // For square web, place player at the midpoint of each side
            switch (playerCurrentLaneIndex) {
                case 0: // Top
                    x = 0;
                    y = WEB_RADIUS * 1.5;
                    break;
                case 1: // Left
                    x = -WEB_RADIUS * 1.5;
                    y = 0;
                    break;
                case 2: // Bottom
                    x = 0;
                    y = -WEB_RADIUS * 1.5;
                    break;
                case 3: // Right
                    x = WEB_RADIUS * 1.5;
                    y = 0;
                    break;
            }
            // Rotation to face inward
            angle = (playerCurrentLaneIndex * Math.PI / 2) + Math.PI / 2;
        } else if (webType === 'triangle') {
            // For triangle web, position at the three corners
            angle = (playerCurrentLaneIndex * Math.PI * 2 / 3);
            const size = WEB_RADIUS * 1.8;
            if (playerCurrentLaneIndex === 0) {
                x = 0;
                y = size;
            } else if (playerCurrentLaneIndex === 1) {
                x = -size;
                y = -size / 2;
            } else {
                x = size;
                y = -size / 2;
            }
        } else {
            // For circle or random polygon
            angle = playerCurrentLaneIndex * LANE_ANGLE_STEP;
            x = WEB_RADIUS * Math.cos(angle);
            y = WEB_RADIUS * Math.sin(angle);
        }

        // Create a position vector
        const position = new THREE.Vector3(x, y, PLAYER_Z);

        // Apply tunnel rotation to player position
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to position
            position.applyMatrix4(rotationMatrix);
        }

        // Update player position
        player.position.copy(position);

        // Update player rotation to face inward and account for tunnel rotation
        player.rotation.z = angle + Math.PI / 2;

        // Apply tunnel rotation to player orientation
        if (webMesh) {
            player.rotation.x = webMesh.rotation.x;
            player.rotation.y = webMesh.rotation.y;
        } else {
            player.rotation.x = 0;
            player.rotation.y = 0;
        }
    }

    // --- Set Game Settings ---
    function setGameSettings(speed, difficulty, web, width, lives, ai) {
        // Player Speed
        switch (speed) {
            case 'slow':
                playerLaneChangeRate = 10;
                break;
            case 'normal':
                playerLaneChangeRate = 6;
                break;
            case 'fast':
                playerLaneChangeRate = 3;
                break;
            default:
                playerLaneChangeRate = 6;
        }

        // Difficulty
        switch (difficulty) {
            case 'easy':
                currentEnemySpeed = 0.03;
                currentEnemySpawnInterval = 80;
                enemiesPerLevel = 15;
                break;
            case 'medium':
                currentEnemySpeed = 0.05;
                currentEnemySpawnInterval = 50;
                enemiesPerLevel = 20;
                break;
            case 'hard':
                currentEnemySpeed = 0.07;
                currentEnemySpawnInterval = 30;
                enemiesPerLevel = 25;
                break;
            default:
                currentEnemySpeed = 0.05;
                currentEnemySpawnInterval = 50;
                enemiesPerLevel = 20;
        }

        // Web Type
        webType = web;

        // Tube Width
        tubeWidth = width;

        // Lives
        // Convert to integer and ensure it's within the valid range
        const livesValue = parseInt(lives);
        if (!isNaN(livesValue) && livesValue >= 3 && livesValue <= 1000) {
            // We don't set the lives variable here, it will be set in startGame
            // This is just to validate the input
        }

        // AI Player
        isAIEnabled = ai === 'on' || ai === 'auto';
        isAIAutoMode = ai === 'auto';

        // Toggle AI learning options visibility
        toggleAILearningOptions();
    }

    // --- Start Game Function ---
    function startGame() {
        if (gameState === 'playing') return;

        // Clear AI auto-restart countdown if active
        clearAIRestartCountdown();

        // Get selected settings
        const selectedSpeed = speedSelect.value;
        const selectedDifficulty = difficultySelect.value;
        const selectedWebType = webTypeSelect.value;
        const selectedTubeWidth = tubeWidthSelect.value;
        const selectedLives = livesSelect.value;
        const selectedAIPlayer = aiPlayerSelect.value;

        setGameSettings(selectedSpeed, selectedDifficulty, selectedWebType, selectedTubeWidth, selectedLives, selectedAIPlayer);

        // Create the web based on selected type
        createWeb(selectedWebType);

        // Reset game state
        score = 0;
        lives = parseInt(selectedLives);
        level = 1;
        enemiesKilled = 0;
        enemiesRequired = enemiesPerLevel;
        enemySpawnTimer = 0;
        playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
        lastLaneChangeFrame = 0;
        activePowerUp = null;
        powerUpTimer = 0;
        bombs = 0; // Reset bombs to 0
        lastBombMilestone = 0; // Reset last bomb milestone

        // Reset AI learning state for new episode
        if (isAIEnabled) {
            // Increment episode count
            aiLearning.episodeCount++;

            // Reset last state and action
            aiLearning.lastState = null;
            aiLearning.lastAction = null;
            aiLearning.lastScore = 0;
            aiLearning.lastLives = lives;
            aiLearning.lastPowerUp = null;

            // Save AI learning data
            saveAILearningData();
        }

        // Load saved rotation state or use defaults
        loadRotationState();

        // Clear existing game objects
        clearGameObjects();

        // Update player
        updatePlayerPosition();

        // Update UI
        updateScoreUI();
        updateHighScoreUI();
        updateLivesUI();
        updateLevelUI();
        updatePowerUpUI();
        updateEnemiesRemainingUI();
        updateBombsUI();

        uiElement.style.display = 'block';
        document.getElementById('power-ups').style.display = 'block';
        document.getElementById('level-indicator').style.display = 'block';
        gameOverScreen.style.display = 'none';
        levelCompleteScreen.style.display = 'none';
        menuElement.style.display = 'none';

        gameState = 'playing';
        isPaused = false;
        player.visible = true;
    }

    // --- Reset for Next Level ---
    function nextLevel() {
        if (gameState !== 'levelcomplete') return;

        // Increase level
        level++;

        // Add 1 life for completing a level
        lives++;
        updateLivesUI();

        // Increase difficulty
        currentEnemySpeed += 0.01;
        currentEnemySpawnInterval = Math.max(currentEnemySpawnInterval - 5, 20);
        enemiesRequired = Math.min(enemiesPerLevel + (level * 5), 50);

        // Reset level-specific variables
        enemiesKilled = 0;
        enemySpawnTimer = 0;

        // Save current rotation state before transitioning to next level
        saveRotationState();

        // Choose a new random web shape for variety
        const webTypes = ['circle', 'square', 'triangle', 'pentagon', 'hexagon', 'octagon', 'random'];
        const newWebType = webTypes[Math.floor(Math.random() * webTypes.length)];
        createWeb(newWebType);

        // Reset player position after new web creation
        playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
        updatePlayerPosition();

        // Clear objects from previous level
        clearGameObjects();

        // Update UI
        updateLevelUI();
        updateEnemiesRemainingUI();
        updateBombsUI();

        // Hide level complete screen
        levelCompleteScreen.style.display = 'none';

        // Resume game
        gameState = 'playing';
        player.visible = true;
    }

    // --- Restart Game Function ---
    function restartGame() {
        gameState = 'menu';
        gameOverScreen.style.display = 'none';
        menuElement.style.display = 'block';
        uiElement.style.display = 'none';
        document.getElementById('power-ups').style.display = 'none';
        document.getElementById('level-indicator').style.display = 'none';

        // Clear AI auto-restart countdown if active
        clearAIRestartCountdown();

        player.visible = false;
        clearGameObjects();
    }

    // --- Clear all game objects ---
    function clearGameObjects() {
        // Remove all enemies
        enemies.forEach(enemy => scene.remove(enemy));
        enemies.length = 0;

        // Remove all projectiles
        projectiles.forEach(p => scene.remove(p));
        projectiles.length = 0;

        // Remove all power-ups
        powerUps.forEach(p => scene.remove(p));
        powerUps.length = 0;

        // Remove all explosions
        explosions.forEach(e => scene.remove(e));
        explosions.length = 0;
    }

    // --- Create Standard Projectile ---
    function createProjectile(isSuperProjectile = false) {
        if (gameState !== 'playing' || isPaused) return;

        // Limit standard projectiles (unless super power active)
        if (!isSuperProjectile && !activePowerUp && projectiles.length > 5) return;

        const projectileGeometry = new THREE.BoxGeometry(0.3, 0.3, 2);

        // Different appearance for super projectiles
        const projectileMaterial = isSuperProjectile ?
          new THREE.MeshPhongMaterial({
              color: 0xff00ff,
              emissive: 0x880088,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.8
          }) :
          new THREE.MeshPhongMaterial({
              color: 0xffff00,
              emissive: 0x888800,
              emissiveIntensity: 0.3
          });

        const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

        // Position at player
        projectile.position.copy(player.position);
        projectile.position.z -= 1.5;

        // Copy player's rotation to align with tunnel rotation
        projectile.rotation.copy(player.rotation);

        // Store projectile properties
        projectile.laneIndex = playerCurrentLaneIndex;
        projectile.isSuper = isSuperProjectile;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, -1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        projectile.direction = direction.normalize();

        scene.add(projectile);
        projectiles.push(projectile);

        // Play sound
        // sounds.fire.play();
    }

    // --- Create Enemy ---
    function createEnemy(isSpecial = false) {
        if (gameState !== 'playing' || isPaused) return;

        // Geometry based on enemy type
        const enemyGeometry = isSpecial ?
          new THREE.OctahedronGeometry(1.2) :
          new THREE.TetrahedronGeometry(1);

        // Material based on enemy type
        const enemyMaterial = isSpecial ?
          new THREE.MeshPhongMaterial({
              color: 0xff0000,
              emissive: 0x880000,
              emissiveIntensity: 0.5,
              shininess: 30
          }) :
          new THREE.MeshPhongMaterial({
              color: 0x00ff00,
              emissive: 0x008800,
              emissiveIntensity: 0.3,
              shininess: 20
          });

        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

        // Random lane
        const laneIndex = Math.floor(Math.random() * NUM_LANES);

        // Position depends on web type
        let x, y;
        let angle;

        if (webType === 'square') {
            switch (laneIndex) {
                case 0: // Top
                    x = 0;
                    y = WEB_RADIUS * 1.5;
                    break;
                case 1: // Left
                    x = -WEB_RADIUS * 1.5;
                    y = 0;
                    break;
                case 2: // Bottom
                    x = 0;
                    y = -WEB_RADIUS * 1.5;
                    break;
                case 3: // Right
                    x = WEB_RADIUS * 1.5;
                    y = 0;
                    break;
            }
            angle = (laneIndex * (Math.PI * 2) / NUM_LANES);
        } else if (webType === 'triangle') {
            const size = WEB_RADIUS * 1.8;
            if (laneIndex === 0) {
                x = 0;
                y = size;
            } else if (laneIndex === 1) {
                x = -size;
                y = -size / 2;
            } else {
                x = size;
                y = -size / 2;
            }
            angle = (laneIndex * (Math.PI * 2) / NUM_LANES);
        } else {
            angle = laneIndex * LANE_ANGLE_STEP;
            x = WEB_RADIUS * Math.cos(angle);
            y = WEB_RADIUS * Math.sin(angle);
        }

        // Create a position vector
        const position = new THREE.Vector3(x, y, ENEMY_START_Z);

        // Apply tunnel rotation to enemy position
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to position
            position.applyMatrix4(rotationMatrix);
        }

        // Set enemy position
        enemy.position.copy(position);

        // Rotate enemy to face roughly towards the center
        enemy.rotation.z = angle;

        // Apply tunnel rotation to enemy orientation
        if (webMesh) {
            enemy.rotation.x = webMesh.rotation.x;
            enemy.rotation.y = webMesh.rotation.y;
        }

        // Add pulsating animation
        enemy.initialScale = isSpecial ? 1.2 : 1.0;
        enemy.pulsePhase = Math.random() * Math.PI * 2; // Random starting phase

        // Store enemy properties
        enemy.laneIndex = laneIndex;
        enemy.isSpecial = isSpecial;
        enemy.points = isSpecial ? 200 : 100;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, 1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        enemy.direction = direction.normalize();

        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- Create Power-Up ---
    function createPowerUp(position) {
        const powerTypes = ['rapidFire', 'extraLife', 'shield', 'superProjectile'];
        const powerType = powerTypes[Math.floor(Math.random() * powerTypes.length)];

        // Create power-up object
        const powerGeometry = new THREE.SphereGeometry(0.8, 8, 8);

        // Color based on power-up type
        let powerColor;
        switch (powerType) {
            case 'rapidFire':
                powerColor = 0xffaa00;
                break; // Orange
            case 'extraLife':
                powerColor = 0xff0000;
                break; // Red
            case 'shield':
                powerColor = 0x0088ff;
                break; // Blue
            case 'superProjectile':
                powerColor = 0xff00ff;
                break; // Magenta
            default:
                powerColor = 0xffffff; // White
        }

        const powerMaterial = new THREE.MeshPhongMaterial({
            color: powerColor,
            emissive: powerColor,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9,
            shininess: 50
        });

        const powerUp = new THREE.Mesh(powerGeometry, powerMaterial);

        // Position at enemy death location (passed in as argument)
        powerUp.position.copy(position);

        // Apply tunnel rotation to power-up orientation
        if (webMesh) {
            powerUp.rotation.x = webMesh.rotation.x;
            powerUp.rotation.y = webMesh.rotation.y;
        }

        // Store power-up properties
        powerUp.powerType = powerType;
        powerUp.rotationSpeed = 0.05;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, 1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        powerUp.direction = direction.normalize();

        scene.add(powerUp);
        powerUps.push(powerUp);

        return powerUp;
    }

    // --- Create Explosion Effect ---
    function createExplosion(position, color) {
        const particleCount = 15;
        const explosionGroup = new THREE.Group();
        explosionGroup.position.copy(position);

        // Create particles
        for (let i = 0; i < particleCount; i++) {
            const particleGeometry = new THREE.SphereGeometry(0.2, 6, 6);
            const particleMaterial = new THREE.MeshPhongMaterial({
                color: color || 0xffaa00,
                emissive: color || 0xffaa00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });

            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // Random position within explosion radius
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = Math.random() * 0.5;

            particle.position.set(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );

            // Random velocity
            particle.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2
            );

            // Lifespan in milliseconds
            particle.life = 500;
            particle.maxLife = 500;

            explosionGroup.add(particle);
        }

        // Add to scene
        scene.add(explosionGroup);
        explosions.push(explosionGroup);

        // Play explosion sound
        // sounds.explode.play();

        return explosionGroup;
    }

    // --- Apply Power-Up ---
    function applyPowerUp(powerType) {
        // Clear any existing power-up
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
        }

        activePowerUp = powerType;
        updatePowerUpUI();

        // Apply power-up effect
        switch (powerType) {
            case 'rapidFire':
                // Rapid fire handled in update loop
                break;
            case 'extraLife':
                lives++;
                updateLivesUI();
                activePowerUp = null; // Immediate effect
                break;
            case 'shield':
                // Shield is handled in collision detection
                break;
            case 'superProjectile':
                // Super projectiles handled in projectile creation and collision
                break;
        }

        // Set timeout to clear power-up after duration (except extraLife which is immediate)
        if (powerType !== 'extraLife') {
            powerUpTimer = setTimeout(() => {
                activePowerUp = null;
                updatePowerUpUI();
            }, POWER_UP_DURATION);
        }

        // Play power-up sound
        // sounds.powerUp.play();
    }

    // --- Update Game State (per frame) ---
    function update(deltaTime) {
        if (gameState !== 'playing' || isPaused) {
            return;
        }

        const currentFrame = renderer.info.render.frame;

        // Update AI player if enabled
        updateAIPlayer(currentFrame);

        // --- Update player position to account for tunnel rotation ---
        if (webMesh) {
            updatePlayerPosition();
        }

        // --- Player Movement ---
        let laneChangeAttempt = false;
        let newLaneIndex = playerCurrentLaneIndex;

        if (keyState['ArrowLeft']) {
            newLaneIndex = (playerCurrentLaneIndex + 1) % NUM_LANES;
            laneChangeAttempt = true;
        } else if (keyState['ArrowRight']) {
            newLaneIndex = (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES;
            laneChangeAttempt = true;
        }

        if (laneChangeAttempt && currentFrame >= lastLaneChangeFrame + playerLaneChangeRate) {
            playerCurrentLaneIndex = newLaneIndex;
            updatePlayerPosition();
            lastLaneChangeFrame = currentFrame;
        }

        // Handle automatic firing for rapid fire power-up
        if (activePowerUp === 'rapidFire' && currentFrame % 5 === 0) {
            createProjectile();
        }

        // --- Update Projectiles ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const projectile = projectiles[i];

            // Move projectile along its direction vector (accounting for tunnel rotation)
            if (projectile.direction) {
                projectile.position.x += projectile.direction.x * PROJECTILE_SPEED;
                projectile.position.y += projectile.direction.y * PROJECTILE_SPEED;
                projectile.position.z += projectile.direction.z * PROJECTILE_SPEED;
            } else {
                // Fallback for projectiles created before this update
                projectile.position.z -= PROJECTILE_SPEED;
            }

            // Super projectiles have a trailing effect
            if (projectile.isSuper && Math.random() > 0.5) {
                const trailGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.5
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(projectile.position);
                scene.add(trail);

                // Fade out trail
                setTimeout(() => {
                    scene.remove(trail);
                    trail.geometry.dispose();
                    trail.material.dispose();
                }, 500);
            }

            // Remove projectile if off screen
            if (projectile.position.z < ENEMY_START_Z - 5) {
                scene.remove(projectile);
                projectiles.splice(i, 1);
            }
        }

        // --- Update Enemies ---
        enemySpawnTimer++;

        // Spawn enemies until we've reached the level's required number
        if (enemySpawnTimer >= currentEnemySpawnInterval && enemies.length < enemiesRequired - enemiesKilled) {
            // Chance to spawn special enemy
            const isSpecial = Math.random() < SPECIAL_ENEMY_CHANCE;
            createEnemy(isSpecial);
            enemySpawnTimer = 0;
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];

            // Move enemy along its direction vector (accounting for tunnel rotation)
            const speed = currentEnemySpeed * (enemy.isSpecial ? 1.2 : 1.0);
            if (enemy.direction) {
                enemy.position.x += enemy.direction.x * speed;
                enemy.position.y += enemy.direction.y * speed;
                enemy.position.z += enemy.direction.z * speed;
            } else {
                // Fallback for enemies created before this update
                enemy.position.z += speed;
            }

            // Pulsating animation
            const pulseScale = enemy.initialScale + Math.sin(enemy.pulsePhase) * 0.1;
            enemy.pulsePhase += 0.05;
            enemy.scale.set(pulseScale, pulseScale, pulseScale);

            // Special enemies also rotate
            if (enemy.isSpecial) {
                enemy.rotation.y += 0.03;
                enemy.rotation.x += 0.02;
            }

            // Check if enemy reached the player's end
            if (enemy.position.z > ENEMY_END_Z) {
                // Player loses a life if not shielded
                if (activePowerUp !== 'shield') {
                    loseLife();
                } else {
                    // Shield absorbs one hit
                    activePowerUp = null;
                    updatePowerUpUI();
                    clearTimeout(powerUpTimer);

                    // Visual effect for shield hit
                    createExplosion(enemy.position, 0x0088ff);
                }

                scene.remove(enemy);
                enemies.splice(i, 1);

                if (gameState !== 'playing') return;
            }
        }

        // --- Update Power-Ups ---
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];

            // Move power-up towards player along its direction vector (accounting for tunnel rotation)
            const speed = currentEnemySpeed * 0.5;
            if (powerUp.direction) {
                powerUp.position.x += powerUp.direction.x * speed;
                powerUp.position.y += powerUp.direction.y * speed;
                powerUp.position.z += powerUp.direction.z * speed;
            } else {
                // Fallback for power-ups created before this update
                powerUp.position.z += speed;
            }

            // Rotate power-up
            powerUp.rotation.y += powerUp.rotationSpeed;
            powerUp.rotation.x += powerUp.rotationSpeed * 0.7;

            // Pulsate size
            const pulseScale = 1 + 0.1 * Math.sin(performance.now() * 0.005);
            powerUp.scale.set(pulseScale, pulseScale, pulseScale);

            // Check if power-up is collected
            if (powerUp.position.z > PLAYER_Z - 1 &&
              Math.abs(powerUp.position.x - player.position.x) < 2 &&
              Math.abs(powerUp.position.y - player.position.y) < 2) {

                // Collect power-up
                applyPowerUp(powerUp.powerType);

                // Remove power-up
                scene.remove(powerUp);
                powerUps.splice(i, 1);
            }

            // Remove if past player
            if (powerUp.position.z > PLAYER_Z + 5) {
                scene.remove(powerUp);
                powerUps.splice(i, 1);
            }
        }

        // --- Update Explosions ---
        for (let i = explosions.length - 1; i >= 0; i--) {
            const explosion = explosions[i];
            let removeExplosion = true;

            // Update each particle
            explosion.children.forEach(particle => {
                particle.position.add(particle.velocity);
                particle.life -= deltaTime;

                // Fade out particle
                if (particle.life > 0) {
                    particle.material.opacity = particle.life / particle.maxLife;
                    removeExplosion = false;
                } else {
                    particle.material.opacity = 0;
                }
            });

            // Remove explosion if all particles are dead
            if (removeExplosion) {
                // Clean up all particles
                explosion.children.forEach(particle => {
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                scene.remove(explosion);
                explosions.splice(i, 1);
            }
        }

        // --- Collision Detection (Projectile vs Enemy) ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const projectile = projectiles[i];
            let projectileHit = false;

            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];

                // Check if in same lane and close enough on Z axis
                if (projectile.laneIndex === enemy.laneIndex &&
                  Math.abs(projectile.position.z - enemy.position.z) < COLLISION_Z_TOLERANCE) {

                    // Collision detected!
                    const hitPoints = enemy.points;
                    addScore(hitPoints);
                    enemiesKilled++;
                    updateEnemiesRemainingUI();

                    // Create explosion effect
                    createExplosion(enemy.position, enemy.isSpecial ? 0xff0000 : 0x00ff00);

                    // Chance to spawn power-up
                    if (Math.random() < POWER_UP_CHANCE || enemy.isSpecial) {
                        createPowerUp(enemy.position);
                    }

                    // Remove enemy
                    scene.remove(enemy);
                    enemies.splice(j, 1);

                    // Super projectiles can pass through enemies
                    if (!projectile.isSuper) {
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        projectileHit = true;
                    }

                    // Check if level is complete
                    if (enemiesKilled >= enemiesRequired) {
                        completedLevel();
                    }

                    // Break inner loop if projectile was destroyed
                    if (projectileHit) break;
                }
            }
        }
    }

    // --- Game Over Logic ---
    function loseLife() {
        if (gameState !== 'playing') return;

        lives--;
        updateLivesUI();

        // Visual indication
        createExplosion(player.position, 0xff0000);

        // Make player flash
        let flashCount = 0;
        const flashInterval = setInterval(() => {
            player.visible = !player.visible;
            flashCount++;
            if (flashCount >= 6) {
                clearInterval(flashInterval);
                player.visible = true;
            }
        }, 200);

        if (lives <= 0) {
            endGame();
        }
    }

    function endGame() {
        if (gameState !== 'playing') return;

        // Save rotation state before ending the game
        saveRotationState();

        gameState = 'gameover';
        finalScoreUI.textContent = 'FINAL SCORE: ' + score;
        finalHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
        gameOverScreen.style.display = 'block';
        uiElement.style.display = 'none';
        document.getElementById('power-ups').style.display = 'none';
        document.getElementById('level-indicator').style.display = 'none';

        // Clear game objects
        clearGameObjects();

        // Hide player
        player.visible = false;

        // Clear power-up timer
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
            activePowerUp = null;
        }

        // Update AI learning for game over
        if (isAIEnabled && aiLearning.lastState && aiLearning.lastAction) {
            // Large negative reward for game over
            const gameOverReward = -150;
            updateQValue(aiLearning.lastState, aiLearning.lastAction, gameOverReward, null);

            // Reset last state and action
            aiLearning.lastState = null;
            aiLearning.lastAction = null;

            // Save AI learning data
            saveAILearningData();
        }

        // Start auto-restart countdown if in auto mode or if AI is enabled with learning data
        if (isAIAutoMode || (isAIEnabled && aiLearning.initialized)) {
            startAIRestartCountdown();
        }
    }

    // --- AI Auto-Restart Countdown ---
    function startAIRestartCountdown() {
        // If in auto mode, restart immediately without countdown
        if (isAIAutoMode) {
            startGame();
            return;
        }

        // Clear any existing countdown
        clearAIRestartCountdown();

        // Reset countdown value
        aiRestartCountdown = 10;
        countdownValueUI.textContent = aiRestartCountdown;

        // Show countdown UI
        aiRestartCountdownUI.style.display = 'block';

        // Start countdown interval
        aiRestartCountdownInterval = setInterval(updateAIRestartCountdown, 1000);
    }

    function updateAIRestartCountdown() {
        // Decrease countdown
        aiRestartCountdown--;
        countdownValueUI.textContent = aiRestartCountdown;

        // Check if countdown is complete
        if (aiRestartCountdown <= 0) {
            // Clear countdown interval
            clearAIRestartCountdown();

            // Start a new game
            startGame();
        }
    }

    function clearAIRestartCountdown() {
        // Clear interval if it exists
        if (aiRestartCountdownInterval) {
            clearInterval(aiRestartCountdownInterval);
            aiRestartCountdownInterval = null;
        }

        // Hide countdown UI
        aiRestartCountdownUI.style.display = 'none';
    }

    // --- Level Complete Logic ---
    function completedLevel() {
        if (gameState !== 'playing') return;

        // Save rotation state before completing the level
        saveRotationState();

        // If in auto mode, automatically proceed to next level after a short delay
        if (isAIAutoMode) {
            // Update AI learning for level completion
            if (isAIEnabled && aiLearning.lastState && aiLearning.lastAction) {
                // Large positive reward for completing a level
                const levelCompletionReward = 200 + (level * 50); // Increases with level
                updateQValue(aiLearning.lastState, aiLearning.lastAction, levelCompletionReward, null);

                // Reset last state and action for next level
                aiLearning.lastState = null;
                aiLearning.lastAction = null;

                // Save AI learning data
                saveAILearningData();
            }

            // Proceed to next level after a short delay
            setTimeout(nextLevel, 2000);

            // Show level complete screen briefly
            gameState = 'levelcomplete';
            levelScoreUI.textContent = 'LEVEL ' + level + ' SCORE: ' + score;
            levelHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
            levelCompleteScreen.style.display = 'block';
            return;
        }

        // Clear AI auto-restart countdown if active and not in auto mode
        clearAIRestartCountdown();

        gameState = 'levelcomplete';
        levelScoreUI.textContent = 'LEVEL ' + level + ' SCORE: ' + score;
        levelHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
        levelCompleteScreen.style.display = 'block';

        // Bonus points for completing level
        const levelBonus = level * 500;
        addScore(levelBonus);

        // Play level complete sound
        // sounds.levelComplete.play();

        // Clear power-up timer
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
            activePowerUp = null;
        }

        // Hide player
        player.visible = false;

        // Update AI learning for level completion
        if (isAIEnabled && aiLearning.lastState && aiLearning.lastAction) {
            // Large positive reward for completing a level
            const levelCompletionReward = 200 + (level * 50); // Increases with level
            updateQValue(aiLearning.lastState, aiLearning.lastAction, levelCompletionReward, null);

            // Reset last state and action for next level
            aiLearning.lastState = null;
            aiLearning.lastAction = null;

            // Save AI learning data
            saveAILearningData();
        }
    }

    // --- UI Updates ---
    function addScore(points) {
        score += points;
        updateScoreUI();

        // Update high score if current score is higher
        if (score > highScore) {
            highScore = score;
            updateHighScoreUI();
            saveHighScore();
        }

        // Check for bomb reward milestone (every 1000 points)
        const currentMilestone = Math.floor(score / BOMB_POINTS);
        if (currentMilestone > lastBombMilestone) {
            // Award a new bomb for each milestone passed
            const newBombs = currentMilestone - lastBombMilestone;

            // Add bombs, but don't exceed the maximum of 30000000
            bombs = Math.min(bombs + newBombs, 3000000);

            // Update the last milestone
            lastBombMilestone = currentMilestone;

            // Update the bombs UI
            updateBombsUI();

            // Visual feedback for getting a new bomb
            const message = newBombs === 1 ? "NEW BOMB ACQUIRED!" : newBombs + " NEW BOMBS ACQUIRED!";
            showMessage(message, 0xffff00);
        }
    }

    // Helper function to show temporary messages
    function showMessage(text, color) {
        // Create a div for the message
        const messageDiv = document.createElement('div');
        messageDiv.textContent = text;
        messageDiv.style.position = 'absolute';
        messageDiv.style.top = '50%';
        messageDiv.style.left = '50%';
        messageDiv.style.transform = 'translate(-50%, -50%)';
        messageDiv.style.color = '#' + color.toString(16);
        messageDiv.style.textShadow = '0 0 10px #' + color.toString(16);
        messageDiv.style.fontSize = '2em';
        messageDiv.style.fontFamily = "'Press Start 2P', cursive";
        messageDiv.style.zIndex = '1000';
        messageDiv.style.pointerEvents = 'none';

        // Add to document
        document.body.appendChild(messageDiv);

        // Fade out and float up after 2 seconds
        setTimeout(() => {
            messageDiv.style.transition = 'opacity 1s, transform 1s';
            messageDiv.style.opacity = '0';
            messageDiv.style.transform = 'translate(-50%, -150%)'; // Move upward while fading
            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 1000);
        }, 1000);
    }

    function updateScoreUI() {
        scoreUI.textContent = 'SCORE: ' + score;
    }

    function updateHighScoreUI() {
        highScoreUI.textContent = 'HIGH SCORE: ' + highScore;
    }

    function updateLivesUI() {
        livesUI.textContent = 'LIVES: ' + lives;
    }

    function updateLevelUI() {
        levelUI.textContent = 'LEVEL: ' + level;
    }

    function updatePowerUpUI() {
        let powerText = 'POWER: ';

        switch (activePowerUp) {
            case 'rapidFire':
                powerText += 'RAPID FIRE';
                break;
            case 'shield':
                powerText += 'SHIELD';
                break;
            case 'superProjectile':
                powerText += 'SUPER SHOT';
                break;
            default:
                powerText += 'NONE';
        }

        powerUpUI.textContent = powerText;
    }

    function updateEnemiesRemainingUI() {
        const remaining = Math.max(0, enemiesRequired - enemiesKilled);
        enemiesRemainingUI.textContent = 'ENEMIES: ' + remaining + '/' + enemiesRequired;
    }

    function updateBombsUI() {
        bombsUI.textContent = 'BOMBS: ' + bombs;
    }

    // --- AI Learning Functions ---

    // Save AI learning data to localStorage
    function saveAILearningData() {
        try {
            localStorage.setItem(STORAGE_KEY_Q_TABLE, JSON.stringify(aiLearning.qTable));
            localStorage.setItem(STORAGE_KEY_AI_STATS, JSON.stringify({
                cumulativeReward: aiLearning.cumulativeReward,
                episodeCount: aiLearning.episodeCount,
                learningRate: aiLearning.learningRate,
                explorationRate: aiLearning.explorationRate
            }));

            // Update UI
            updateAILearningUI();
        } catch (e) {
            console.error("Failed to save AI learning data to localStorage:", e);
        }
    }

    // Load AI learning data from localStorage
    function loadAILearningData() {
        try {
            const savedQTable = localStorage.getItem(STORAGE_KEY_Q_TABLE);
            const savedStats = localStorage.getItem(STORAGE_KEY_AI_STATS);

            if (savedQTable) {
                aiLearning.qTable = JSON.parse(savedQTable);
                aiLearning.initialized = true;
            }

            if (savedStats) {
                const stats = JSON.parse(savedStats);
                aiLearning.cumulativeReward = stats.cumulativeReward || 0;
                aiLearning.episodeCount = stats.episodeCount || 0;

                // Load learning parameters if available
                if (stats.learningRate) aiLearning.learningRate = stats.learningRate;
                if (stats.explorationRate) aiLearning.explorationRate = stats.explorationRate;
            }

            // Update UI
            updateAILearningUI();
        } catch (e) {
            console.error("Failed to load AI learning data from localStorage:", e);
            // Initialize with empty data if loading fails
            aiLearning.qTable = {};
            aiLearning.cumulativeReward = 0;
            aiLearning.episodeCount = 0;
        }
    }

    // Reset AI learning data
    function resetAILearningData() {
        if (confirm("Are you sure you want to reset AI learning data? This cannot be undone.")) {
            aiLearning.qTable = {};
            aiLearning.cumulativeReward = 0;
            aiLearning.episodeCount = 0;
            aiLearning.lastState = null;
            aiLearning.lastAction = null;
            aiLearning.initialized = true;

            // Save reset data
            saveAILearningData();

            alert("AI learning data has been reset.");
        }
    }

    // Update AI learning UI
    function updateAILearningUI() {
        // Update episodes and reward display
        aiEpisodesDisplay.textContent = aiLearning.episodeCount;
        aiRewardDisplay.textContent = Math.round(aiLearning.cumulativeReward);

        // Update learning rate select
        for (let i = 0; i < aiLearningRateSelect.options.length; i++) {
            if (parseFloat(aiLearningRateSelect.options[i].value) === aiLearning.learningRate) {
                aiLearningRateSelect.selectedIndex = i;
                break;
            }
        }

        // Update exploration rate select
        for (let i = 0; i < aiExplorationRateSelect.options.length; i++) {
            if (parseFloat(aiExplorationRateSelect.options[i].value) === aiLearning.explorationRate) {
                aiExplorationRateSelect.selectedIndex = i;
                break;
            }
        }
    }

    // Toggle AI learning options visibility
    function toggleAILearningOptions() {
        if (aiPlayerSelect.value === 'on' || aiPlayerSelect.value === 'auto') {
            aiLearningOptions.style.display = 'flex';

            // Show or hide auto mode indicator
            aiAutoModeIndicator.style.display = aiPlayerSelect.value === 'auto' ? 'block' : 'none';

            // Load AI learning data if not already loaded
            if (!aiLearning.initialized) {
                loadAILearningData();
            } else {
                updateAILearningUI();
            }
        } else {
            aiLearningOptions.style.display = 'none';
        }
    }

    // Encode the current game state into a string
    function encodeGameState() {
        // Find the closest enemy in the current lane
        let closestEnemyInLane = null;
        let closestEnemyDistance = Infinity;

        // Find enemies in adjacent lanes
        let enemiesInAdjacentLanes = [];

        // Find power-ups
        let closestPowerUp = null;
        let closestPowerUpDistance = Infinity;

        // Check all enemies
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            const distanceToPlayer = enemy.position.z - PLAYER_Z;

            // Check if enemy is in the current lane
            if (enemy.laneIndex === playerCurrentLaneIndex) {
                if (distanceToPlayer < closestEnemyDistance && distanceToPlayer > 0) {
                    closestEnemyInLane = enemy;
                    closestEnemyDistance = distanceToPlayer;
                }
            }
            // Check if enemy is in adjacent lanes
            else if (
              enemy.laneIndex === (playerCurrentLaneIndex + 1) % NUM_LANES ||
              enemy.laneIndex === (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES
            ) {
                enemiesInAdjacentLanes.push({
                    enemy: enemy,
                    distance: distanceToPlayer
                });
            }
        }

        // Check all power-ups
        for (let i = 0; i < powerUps.length; i++) {
            const powerUp = powerUps[i];
            const distanceToPlayer = Math.abs(powerUp.position.z - PLAYER_Z);

            if (distanceToPlayer < closestPowerUpDistance) {
                closestPowerUp = powerUp;
                closestPowerUpDistance = distanceToPlayer;
            }
        }

        // Discretize the state to reduce state space
        // Enemy in current lane: none, far, medium, close
        let enemyInLane = "none";
        if (closestEnemyInLane) {
            if (closestEnemyDistance < 5) enemyInLane = "close";
            else if (closestEnemyDistance < 15) enemyInLane = "medium";
            else enemyInLane = "far";
        }

        // Enemies in adjacent lanes: none, left, right, both
        let enemiesAdjacent = "none";
        let leftEnemies = enemiesInAdjacentLanes.filter(e =>
          e.enemy.laneIndex === (playerCurrentLaneIndex + 1) % NUM_LANES);
        let rightEnemies = enemiesInAdjacentLanes.filter(e =>
          e.enemy.laneIndex === (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES);

        if (leftEnemies.length > 0 && rightEnemies.length > 0) enemiesAdjacent = "both";
        else if (leftEnemies.length > 0) enemiesAdjacent = "left";
        else if (rightEnemies.length > 0) enemiesAdjacent = "right";

        // Power-up: none, far, close
        let powerUpState = "none";
        if (closestPowerUp) {
            if (closestPowerUpDistance < 10) powerUpState = "close";
            else powerUpState = "far";
        }

        // Active power-up: none, rapidFire, shield, superProjectile
        let activePowerUpState = activePowerUp || "none";

        // Encode the state as a string
        return `${enemyInLane}|${enemiesAdjacent}|${powerUpState}|${activePowerUpState}`;
    }

    // Get the Q-value for a state-action pair
    function getQValue(state, action) {
        if (!aiLearning.qTable[state]) {
            aiLearning.qTable[state] = {
                "fire": 0,
                "moveLeft": 0,
                "moveRight": 0,
                "doNothing": 0
            };
        }
        return aiLearning.qTable[state][action];
    }

    // Update Q-value based on reward and next state
    function updateQValue(state, action, reward, nextState) {
        if (!state || !action) return; // Skip if no previous state or action

        // Get current Q-value
        const currentQ = getQValue(state, action);

        // Find max Q-value for next state
        let maxNextQ = 0;
        if (nextState) {
            const actions = ["fire", "moveLeft", "moveRight", "doNothing"];
            maxNextQ = Math.max(...actions.map(a => getQValue(nextState, a)));
        }

        // Q-learning update formula: Q(s,a) = Q(s,a) +  * [r +  * max Q(s',a') - Q(s,a)]
        const newQ = currentQ + aiLearning.learningRate * (
          reward + aiLearning.discountFactor * maxNextQ - currentQ
        );

        // Update Q-table
        if (!aiLearning.qTable[state]) {
            aiLearning.qTable[state] = {
                "fire": 0,
                "moveLeft": 0,
                "moveRight": 0,
                "doNothing": 0
            };
        }
        aiLearning.qTable[state][action] = newQ;

        // Update cumulative reward
        aiLearning.cumulativeReward += reward;

        // Save learning data periodically (every 100 updates)
        if (Math.random() < 0.01) { // 1% chance to save on each update
            saveAILearningData();
        }
    }

    // Choose an action based on the current state using epsilon-greedy policy
    function chooseAction(state) {
        // Exploration: choose random action with probability epsilon
        if (Math.random() < aiLearning.explorationRate) {
            const actions = ["fire", "moveLeft", "moveRight", "doNothing"];
            return actions[Math.floor(Math.random() * actions.length)];
        }

        // Exploitation: choose action with highest Q-value
        const qValues = aiLearning.qTable[state] || {
            "fire": 0,
            "moveLeft": 0,
            "moveRight": 0,
            "doNothing": 0
        };

        // Find action with highest Q-value
        let bestAction = "doNothing";
        let bestValue = qValues[bestAction];

        for (const action in qValues) {
            if (qValues[action] > bestValue) {
                bestValue = qValues[action];
                bestAction = action;
            }
        }

        return bestAction;
    }

    // --- AI Player Logic ---
    function updateAIPlayer(currentFrame) {
        if (!isAIEnabled || gameState !== 'playing' || isPaused) {
            return;
        }

        // Initialize AI learning if not already done
        if (!aiLearning.initialized) {
            loadAILearningData();
            aiLearning.initialized = true;
        }

        // Only make decisions at certain intervals to avoid erratic behavior
        aiDecisionTimer++;
        if (aiDecisionTimer < AI_DECISION_INTERVAL) {
            return;
        }
        aiDecisionTimer = 0;

        // Encode the current game state
        const currentState = encodeGameState();

        // If we have a previous state and action, calculate reward and update Q-value
        if (aiLearning.lastState && aiLearning.lastAction) {
            // Calculate reward based on game events since last decision
            let reward = 0;

            // Small negative reward for each time step (encourages efficiency)
            reward -= 0.1;

            // Check for enemies killed (positive reward)
            // This is an approximation since we don't track exactly which enemies were killed
            // A more accurate implementation would hook into the addScore function
            const enemiesKilledSinceLastDecision = Math.max(0, score - aiLearning.lastScore);
            if (enemiesKilledSinceLastDecision > 0) {
                reward += enemiesKilledSinceLastDecision * 10; // Significant positive reward for killing enemies
            }

            // Check for power-ups collected (positive reward)
            if (activePowerUp && activePowerUp !== aiLearning.lastPowerUp) {
                reward += 20; // Significant positive reward for collecting power-ups
            }

            // Check for lives lost (negative reward)
            if (lives < aiLearning.lastLives) {
                reward -= 100; // Large negative reward for losing a life
            }

            // Update Q-value
            updateQValue(aiLearning.lastState, aiLearning.lastAction, reward, currentState);
        }

        // Choose an action based on the current state
        const action = chooseAction(currentState);

        // Execute the chosen action
        let shouldMove = false;
        let moveDirection = null;
        let shouldFire = false;

        switch (action) {
            case "fire":
                shouldFire = true;
                break;
            case "moveLeft":
                shouldMove = true;
                moveDirection = "left";
                break;
            case "moveRight":
                shouldMove = true;
                moveDirection = "right";
                break;
            case "doNothing":
                // Do nothing
                break;
        }

        // Execute decisions
        if (shouldFire) {
            createProjectile(activePowerUp === 'superProjectile');
        }

        if (shouldMove && currentFrame >= lastLaneChangeFrame + playerLaneChangeRate) {
            let newLaneIndex = playerCurrentLaneIndex;

            if (moveDirection === 'left') {
                newLaneIndex = (playerCurrentLaneIndex + 1) % NUM_LANES;
            } else if (moveDirection === 'right') {
                newLaneIndex = (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES;
            }

            playerCurrentLaneIndex = newLaneIndex;
            updatePlayerPosition();
            lastLaneChangeFrame = currentFrame;
        }

        // Store current state and action for next update
        aiLearning.lastState = currentState;
        aiLearning.lastAction = action;
        aiLearning.lastScore = score;
        aiLearning.lastLives = lives;
        aiLearning.lastPowerUp = activePowerUp;
    }

    // Helper function to decide the best lane to move to
    function decideBestLaneToMove(enemiesInAdjacentLanes) {
        // Count enemies in each adjacent lane
        let leftLaneIndex = (playerCurrentLaneIndex + 1) % NUM_LANES;
        let rightLaneIndex = (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES;

        let leftLaneEnemies = enemiesInAdjacentLanes.filter(e => e.enemy.laneIndex === leftLaneIndex);
        let rightLaneEnemies = enemiesInAdjacentLanes.filter(e => e.enemy.laneIndex === rightLaneIndex);

        // Choose the lane with fewer enemies
        if (leftLaneEnemies.length < rightLaneEnemies.length) {
            return 'left';
        } else if (rightLaneEnemies.length < leftLaneEnemies.length) {
            return 'right';
        } else {
            // If equal, choose randomly
            return Math.random() < 0.5 ? 'left' : 'right';
        }
    }

    // Helper function to find the lane index for a given position
    function findLaneForPosition(position) {
        // This is a simplified version that works best for circular webs
        // For other web types, more complex calculations would be needed
        let angle = Math.atan2(position.y, position.x);
        if (angle < 0) angle += Math.PI * 2;

        return Math.floor(angle / LANE_ANGLE_STEP) % NUM_LANES;
    }

    // --- Web Rotation Update ---
    function updateWebRotation() {
        if (webMesh) {
            // Smoothly interpolate current rotation towards target rotation only if rotation is enabled and game is not over
            if (isRotationEnabled && gameState !== 'gameover' && gameState !== 'levelcomplete') {
                webMesh.rotation.y += (targetRotationY - webMesh.rotation.y) * 0.05;
                webMesh.rotation.x += (targetRotationX - webMesh.rotation.x) * 0.05;
            }

            // Keep subtle z-rotation for visual effect regardless of rotation enabled state
            webMesh.rotation.z += 0.0005;
        }
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);

        // Calculate delta time
        const currentTime = performance.now();
        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        // Always update web rotation, even when paused
        updateWebRotation();

        // Update game state
        if (!isPaused) {
            update(deltaTime);
        }

        // Render
        renderer.render(scene, camera);
    }

    // --- Event Handlers ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
        keyState[event.key] = true;

        // Handle firing
        if (gameState === 'playing' && event.key === ' ') {
            // Create super projectile if power-up is active
            createProjectile(activePowerUp === 'superProjectile');
        }

        // Handle bomb activation
        if (gameState === 'playing' && !isPaused && event.key.toLowerCase() === 'b') {
            activateBomb();
        }

        // Toggle pause
        if (gameState === 'playing' && (event.key === 'p' || event.key === 'Enter')) {
            isPaused = !isPaused;
            pauseScreen.style.display = isPaused ? 'block' : 'none';
            menuElement.style.display = isPaused ? 'block' : 'none';

            if (!isPaused) {
                // Apply settings when resuming
                applyGameSettings();
            }
        }

        // Prevent scrolling when pressing space, arrow keys, or Enter
        if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', 'b', 'B'].includes(event.key)) {
            event.preventDefault();
        }
    }

    function onKeyUp(event) {
        keyState[event.key] = false;
    }

    function onMouseMove(event) {
        // Calculate mouse position relative to the center of the screen
        mouseX = (event.clientX - window.innerWidth / 2) / (window.innerWidth / 2);
        mouseY = (event.clientY - window.innerHeight / 2) / (window.innerHeight / 2);

        // Set target rotation based on mouse position only if rotation is enabled and game is not over
        if (isRotationEnabled && gameState !== 'gameover' && gameState !== 'levelcomplete') {
            targetRotationY = mouseX * 0.5; // Horizontal movement controls Y rotation
            targetRotationX = mouseY * 0.3; // Vertical movement controls X rotation

            // Debounced save of rotation state
            if (saveRotationTimer) {
                clearTimeout(saveRotationTimer);
            }
            saveRotationTimer = setTimeout(() => {
                saveRotationState();
                saveRotationTimer = null;
            }, 500); // Save after 500ms of no movement
        }
    }

    function onMouseClick(event) {
        // Allow toggling rotation if game is playing, even when paused
        if (gameState === 'playing') {
            // Toggle rotation enabled flag
            isRotationEnabled = !isRotationEnabled;

            // Save rotation state to localStorage
            saveRotationState();
        }
    }

    // --- Bomb Activation Function ---
    function activateBomb() {
        // Check if there are bombs available
        if (bombs <= 0) return;

        // Decrease bomb count
        bombs--;
        updateBombsUI();

        // Create a large explosion effect at the center of the web
        const centerExplosion = createExplosion(new THREE.Vector3(0, 0, 0), 0xff0000);
        centerExplosion.scale.set(3, 3, 3); // Make the explosion larger

        // Track total points from destroyed enemies
        let totalPoints = 0;

        // Destroy all visible enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];

            // Add points for each enemy
            totalPoints += enemy.points;

            // Create explosion effect at enemy position
            createExplosion(enemy.position, enemy.isSpecial ? 0xff0000 : 0x00ff00);

            // Remove enemy
            scene.remove(enemy);
            enemies.splice(i, 1);

            // Increment enemies killed count
            enemiesKilled++;
        }

        // Add score for destroyed enemies
        if (totalPoints > 0) {
            addScore(totalPoints);
            updateEnemiesRemainingUI();
        }

        // Check if level is complete
        if (enemiesKilled >= enemiesRequired) {
            completedLevel();
        }
    }

    // --- Apply Game Settings ---
    function applyGameSettings() {
        // Get selected settings
        const selectedSpeed = speedSelect.value;
        const selectedDifficulty = difficultySelect.value;
        const selectedWebType = webTypeSelect.value;
        const selectedTubeWidth = tubeWidthSelect.value;
        const selectedLives = livesSelect.value;
        const selectedAIPlayer = aiPlayerSelect.value;

        // Apply settings
        setGameSettings(selectedSpeed, selectedDifficulty, selectedWebType, selectedTubeWidth, selectedLives, selectedAIPlayer);

        // Recreate the web if the web type has changed
        if (webType !== selectedWebType) {
            createWeb(selectedWebType);
            // Reset player position after new web creation
            playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
            updatePlayerPosition();
        }
    }

    // --- Start the Game ---
    init();
</script>
</body>
</html>
