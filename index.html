<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TEMPESTO</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #00ff00;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            touch-action: none; /* Prevent browser handling of touch events */
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }

        /* Mobile touch controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: none; /* Hidden by default, shown on mobile */
            z-index: 0;
            pointer-events: all;
        }

        .control-row {
            display: flex;
            justify-content: start;
            margin-bottom: 10px;
            padding: 0 20px;
        }

        .touch-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            font-size: 24px;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            user-select: none;
            touch-action: none;
            margin: 5px;
        }

        .touch-button:active {
            background-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        #fire-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
            color: #ff0000;
            text-shadow: 0 0 5px #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }

        #fire-button:active {
            background-color: rgba(255, 0, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

        #bomb-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 0, 0.2);
            border: 2px solid rgba(255, 255, 0, 0.5);
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.3);
        }

        #bomb-button:active {
            background-color: rgba(255, 255, 0, 0.4);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
        }

        #pause-button {
            background-color: rgba(0, 255, 0, 0.2);
            border: 2px solid rgba(0, 255, 0, 0.5);
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        #rotate-button {
            background-color: rgba(255, 0, 255, 0.2);
            border: 2px solid rgba(255, 0, 255, 0.5);
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            font-size: 16px;
        }

        #rotate-button:active {
            background-color: rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        /* Shared styles for UI and Menu */
        #ui, #game-over, #menu, #level-complete {
            position: absolute;
            /*z-index: 100;*/
            pointer-events: none;
            text-shadow: 0 0 5px;
            font-size: 1em;
        }

        #ui {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            /*max-width: 600px;*/
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            display: flex;
            flex-direction: column;
            gap: 5px;
            /*background-color: rgba(0, 0, 0, 0.8);*/
            /*border: 2px solid #00ffff;*/
            /*border-radius: 8px;*/
            /*padding: 8px;*/
            /*box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.2);*/
            position: relative;
            z-index: 200;
        }

        #ui:before {
            content: "TEMPESTO";
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #000;
            padding: 0 10px;
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .ui-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 3px 0;
            /*border-bottom: 1px solid rgba(0, 255, 255, 0.3);*/
        }

        #ui-row:last-child {
            border-bottom: none;
        }

        #score, #high-score {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            padding: 3px 6px;
            background-color: rgba(255, 255, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.2);
            letter-spacing: 1px;
        }

        #lives, #bombs {
            color: #ff5555;
            text-shadow: 0 0 8px #ff0000;
            padding: 3px 6px;
            background-color: rgba(255, 0, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.2);
            letter-spacing: 0px;
        }

        #enemies-remaining {
            color: #55ff55;
            text-shadow: 0 0 8px #00ff00;
            padding: 3px 6px;
            background-color: rgba(0, 255, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
            letter-spacing: 0px;
        }

        #power-ups #active-power {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            padding: 3px 6px;
            background-color: rgba(255, 0, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 0, 255, 0.2);
            letter-spacing: 0px;
        }

        #level-indicator #current-level {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            padding: 3px 6px;
            background-color: rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.2);
            letter-spacing: 0px;
            font-size: 1em;
            font-weight: bold;
            display: inline-block;
        }

        #game-over, #level-complete {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: all;
        }

        #game-over {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        #level-complete {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #game-over h1, #level-complete h1 {
            margin: 0 0 15px 0;
            font-size: 2.5em;
        }

        #game-over #final-score, #level-complete #level-score {
            margin-bottom: 20px;
        }

        #menu {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffff00;
            padding: 30px;
            text-align: center;
            color: #ffff00;
            text-shadow: 0 0 5px #ffff00;
            pointer-events: all;
            max-width: 90%;
            width: 400px;
            box-sizing: border-box;
        }

        #menu h1 {
            margin: 0 0 20px 0;
            font-size: 1.8em;
            text-shadow: 0 0 10px #ffff00;
        }

        #menu div {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #menu label {
            margin-right: 10px;
            white-space: nowrap;
        }

        #menu select, #menu button, #game-over button, #level-complete button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #000;
            color: #ffff00;
            border: 2px solid #ffff00;
            text-shadow: 0 0 5px #ffff00;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            font-size: 0.8em;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            border-radius: 0;
            min-width: 100px;
        }

        #menu select option {
            background-color: #000;
            color: #ffff00;
        }

        #menu button, #game-over button, #level-complete button {
            width: 100%;
            margin-top: 10px;
        }

        #menu button:hover, #game-over button:hover, #level-complete button:hover {
            text-shadow: 0 0 15px #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        /* Power-up indicator */
        #power-ups {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            font-weight: bold;
        }

        /* Level indicator */
        #level-indicator {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Pause screen */
        #pause-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff;
            font-size: 2em;
            display: none;
            z-index: 101;
        }

        /* Instructions */
        #instructions-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8em;
            z-index: 102;
            display: none;
            max-width: 90%;
            width: 500px;
            box-sizing: border-box;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #instructions-modal h2 {
            margin-top: 0;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        #instructions-modal button {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #000;
            color: #00ffff;
            border: 2px solid #00ffff;
            text-shadow: 0 0 5px #00ffff;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            font-size: 0.8em;
            margin-top: 15px;
            width: 100%;
        }

        #instructions-modal button:hover {
            text-shadow: 0 0 15px #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        #instructions-button {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            z-index: 100;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');
    </style>
</head>
<body>

<div id="pause-screen">PAUSED</div>

<div id="instructions-modal">
    <h2>INSTRUCTIONS</h2>
    <p>ARROWS: MOVE | SPACE: FIRE | B: BOMB | P/ENTER: PAUSE</p>
    <p>MOUSE: ROTATE TUNNEL | CLICK: TOGGLE ROTATION</p>
    <button id="close-instructions-button">CLOSE</button>
</div>

<div id="instructions-button">INSTRUCTIONS</div>
<!-- Mobile touch controls -->
<div id="mobile-controls">
    <div style="display: flex; justify-content: space-between; width: 100%">
    <div class="control-row">
        <div id="left-button" class="touch-button">←</div>
        <div id="right-button" class="touch-button">→</div>
    </div>
    <div class="control-row">
        <div id="bomb-button" class="touch-button">BOMB</div>
        <div id="fire-button" class="touch-button">FIRE</div>
    </div>
    </div>
</div>

<div id="game-over">
    <h1>GAME OVER</h1>
    <div id="final-score"></div>
    <div id="final-high-score"></div>
    <button id="restart-button">RESTART</button>
</div>

<div id="level-complete">
    <h1>LEVEL COMPLETE</h1>
    <div id="level-score"></div>
    <div id="level-high-score"></div>
    <button id="next-level-button">NEXT LEVEL</button>
</div>

<div id="menu">
    <h1>TEMPESTO</h1>
    <div>
        <label for="speed-select">PLAYER SPEED:</label>
        <select id="speed-select">
            <option value="slow">SLOW</option>
            <option value="normal" selected>NORMAL</option>
            <option value="fast">FAST</option>
        </select>
    </div>
    <div>
        <label for="difficulty-select">DIFFICULTY:</label>
        <select id="difficulty-select">
            <option value="easy">EASY</option>
            <option value="medium" selected>MEDIUM</option>
            <option value="hard">HARD</option>
        </select>
    </div>
    <div>
        <label for="web-type-select">WEB TYPE:</label>
        <select id="web-type-select">
            <option value="circle" selected>CIRCLE</option>
            <option value="square">SQUARE</option>
            <option value="triangle">TRIANGLE</option>
            <option value="pentagon">PENTAGON</option>
            <option value="hexagon">HEXAGON</option>
            <option value="octagon">OCTAGON</option>
            <option value="random">RANDOM</option>
        </select>
    </div>
    <div>
        <label for="tube-width-select">TUBE WIDTH:</label>
        <select id="tube-width-select">
            <option value="wire">WIRE</option>
            <option value="small">SMALL</option>
            <option value="medium" selected>MEDIUM</option>
            <option value="large">LARGE</option>
        </select>
    </div>
    <div>
        <label for="lives-select">LIVES:</label>
        <select id="lives-select">
            <option value="3" selected>3</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
        </select>
    </div>
    <button id="start-button">START GAME</button>
</div>

<div id="ui" style="display: none">
    <div class="ui-row">
        <div id="score">SCORE: 0</div>
        <div id="high-score">HIGH SCORE: 0</div>
    </div>
    <div class="ui-row">
        <div id="lives">LIVES: 3</div>
        <div id="enemies-remaining">ENEMIES: 0/0</div>
    </div>
    <div class="ui-row">
        <div id="bombs">BOMBS: 3</div>
        <div id="power-ups">
            <div id="active-power">POWER: NONE</div>
        </div>
    </div>
    <div class="ui-row" style="align-items: center;">
        <div id="level-indicator">
            <div id="current-level">LEVEL: 1</div>
        </div>
    </div>
</div>

<!-- Include Three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- Global Variables ---
    let scene, camera, renderer;
    let webMesh;
    let player;
    const projectiles = [];
    const enemies = [];
    const powerUps = [];
    const explosions = [];
    const keyState = {};


    // Mouse tracking variables
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;
    let isRotationEnabled = false; // Flag to enable/disable tunnel rotation

    // localStorage keys
    const STORAGE_KEY_ROTATION_X = 'tempest3d_rotationX';
    const STORAGE_KEY_ROTATION_Y = 'tempest3d_rotationY';
    const STORAGE_KEY_ROTATION_ENABLED = 'tempest3d_rotationEnabled';
    const STORAGE_KEY_HIGH_SCORE = 'tempest3d_highScore';

    // Debounce timer for saving rotation state
    let saveRotationTimer = null;

    // Game State
    let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameover', 'levelcomplete'
    let isPaused = false;


    // Web Configuration
    let NUM_LANES = 16;
    const WEB_DEPTH = 80;
    const WEB_RADIUS = 8;
    let LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;
    let webType = 'circle';
    let tubeWidth = 'medium'; // Options: 'wire', 'small', 'medium', 'large'

    // Fixed Z positions
    const PLAYER_Z = WEB_DEPTH / 2;
    const ENEMY_START_Z = -WEB_DEPTH / 2 + 1;
    const ENEMY_END_Z = WEB_DEPTH / 2 - 2;

    // Game mechanics
    const PROJECTILE_SPEED = 0.6;
    const COLLISION_Z_TOLERANCE = 1.0;
    const POWER_UP_CHANCE = 0.15; // 15% chance of power-up spawn per enemy kill
    const POWER_UP_DURATION = 10000; // 10 seconds
    const SPECIAL_ENEMY_CHANCE = 0.1; // 10% chance of special enemy
    const BOMB_POINTS = 3000;
    // Configurable Settings
    let playerLaneChangeRate = 6;
    let currentEnemySpeed = 0.05;
    let currentEnemySpawnInterval = 50;
    let enemiesPerLevel = 20;

    // Game stats
    let score = 0;
    let highScore = 0;
    let lives = 3;
    let level = 1;
    let enemiesKilled = 0;
    let enemiesRequired = enemiesPerLevel;
    let enemySpawnTimer = 0;
    let playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
    let lastLaneChangeFrame = 0;
    let activePowerUp = null;
    let powerUpTimer = 0;
    let lastFrameTime = 0;

    // Bomb variables
    let bombs = 0; // Start with 3 bombs
    let lastBombMilestone = 0; // Track the last score milestone for bomb rewards

    // Sound effects (placeholders)
    const sounds = {
        fire: new Audio(),
        explode: new Audio(),
        powerUp: new Audio(),
        levelComplete: new Audio()
    };

    // --- UI Elements ---
    const uiElement = document.getElementById('ui');
    const scoreUI = document.getElementById('score');
    const highScoreUI = document.getElementById('high-score');
    const livesUI = document.getElementById('lives');
    const enemiesRemainingUI = document.getElementById('enemies-remaining');
    const bombsUI = document.getElementById('bombs');
    const powerUpUI = document.getElementById('active-power');
    const levelUI = document.getElementById('current-level');
    const pauseScreen = document.getElementById('pause-screen');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreUI = document.getElementById('final-score');
    const finalHighScoreUI = document.getElementById('final-high-score');
    const restartButton = document.getElementById('restart-button');
    const levelCompleteScreen = document.getElementById('level-complete');
    const levelScoreUI = document.getElementById('level-score');
    const levelHighScoreUI = document.getElementById('level-high-score');
    const nextLevelButton = document.getElementById('next-level-button');
    const menuElement = document.getElementById('menu');
    const speedSelect = document.getElementById('speed-select');
    const difficultySelect = document.getElementById('difficulty-select');
    const webTypeSelect = document.getElementById('web-type-select');
    const tubeWidthSelect = document.getElementById('tube-width-select');
    const livesSelect = document.getElementById('lives-select');
    const startButton = document.getElementById('start-button');


    // --- Save and Load Rotation State ---
    function saveRotationState() {
        try {
            localStorage.setItem(STORAGE_KEY_ROTATION_X, targetRotationX);
            localStorage.setItem(STORAGE_KEY_ROTATION_Y, targetRotationY);
            localStorage.setItem(STORAGE_KEY_ROTATION_ENABLED, isRotationEnabled);
        } catch (e) {
            console.error("Failed to save rotation state to localStorage:", e);
        }
    }

    function loadRotationState() {
        try {
            const savedRotationX = localStorage.getItem(STORAGE_KEY_ROTATION_X);
            const savedRotationY = localStorage.getItem(STORAGE_KEY_ROTATION_Y);
            const savedRotationEnabled = localStorage.getItem(STORAGE_KEY_ROTATION_ENABLED);

            if (savedRotationX !== null) {
                targetRotationX = parseFloat(savedRotationX);
            }

            if (savedRotationY !== null) {
                targetRotationY = parseFloat(savedRotationY);
            }

            if (savedRotationEnabled !== null) {
                isRotationEnabled = savedRotationEnabled === 'true';
            }
        } catch (e) {
            console.error("Failed to load rotation state from localStorage:", e);
        }
    }

    // --- Save and Load High Score ---
    function saveHighScore() {
        try {
            localStorage.setItem(STORAGE_KEY_HIGH_SCORE, highScore);
        } catch (e) {
            console.error("Failed to save high score to localStorage:", e);
        }
    }

    function loadHighScore() {
        try {
            const savedHighScore = localStorage.getItem(STORAGE_KEY_HIGH_SCORE);

            if (savedHighScore !== null) {
                highScore = parseInt(savedHighScore);
                updateHighScoreUI();
            }
        } catch (e) {
            console.error("Failed to load high score from localStorage:", e);
        }
    }

    // --- Mobile Controls Setup ---
    function setupMobileControls() {
        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (window.innerWidth <= 800 && window.innerHeight <= 600);

        // Get mobile controls container
        const mobileControls = document.getElementById('mobile-controls');

        // Show mobile controls if on mobile device and if the element exists
        if (isMobile && mobileControls) {
            mobileControls.style.display = 'flex';

            // Update instructions modal for mobile
            const instructionsModal = document.getElementById('instructions-modal');
            if (instructionsModal) {
                // Update the content of the instructions modal for mobile
                instructionsModal.innerHTML = `
                    <h2>INSTRUCTIONS</h2>
                    <p>TOUCH: LEFT BUTTON MOVES RIGHT, RIGHT BUTTON MOVES LEFT</p>
                    <p>SWIPE: LEFT TO MOVE RIGHT, RIGHT TO MOVE LEFT</p>
                    <p>FIRE BUTTON: SHOOT | BOMB BUTTON: BOMB</p>
                    <p>PAUSE BUTTON: PAUSE | ROTATE BUTTON: TOGGLE ROTATION</p>
                    <p>DRAG: ROTATE TUNNEL</p>
                    <button id="close-instructions-button">CLOSE</button>
                `;

                // Re-add event listener for close button
                const closeInstructionsButton = document.getElementById('close-instructions-button');
                if (closeInstructionsButton) {
                    closeInstructionsButton.addEventListener('click', function() {
                        instructionsModal.style.display = 'none';
                        isPaused = false;
                    });
                }
            }

            // Get control buttons
            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');
            const fireButton = document.getElementById('fire-button');
            const bombButton = document.getElementById('bomb-button');
            const pauseButton = document.getElementById('pause-button');
            const rotateButton = document.getElementById('rotate-button');
            const pauseScreen = document.getElementById('pause-screen');
            const menuElement = document.getElementById('menu');

            // Touch event handlers for directional buttons
            if (leftButton) {
                leftButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keyState['ArrowRight'] = true;
                });

                leftButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keyState['ArrowRight'] = false;
                });
            }

            if (rightButton) {
                rightButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keyState['ArrowLeft'] = true;
                });

                rightButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keyState['ArrowLeft'] = false;
                });
            }

            // Fire button
            if (fireButton) {
                fireButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keyState[' '] = true;
                    if (gameState === 'playing') {
                        createProjectile(activePowerUp === 'superProjectile');
                    }
                });

                fireButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keyState[' '] = false;
                });
            }

            // Bomb button
            if (bombButton) {
                bombButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    if (gameState === 'playing' && !isPaused) {
                        activateBomb();
                    }
                });
            }

            // Pause button
            if (pauseButton && pauseScreen && menuElement) {
                pauseButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    if (gameState === 'playing') {
                        // Check if instructions modal is visible
                        const instructionsModal = document.getElementById('instructions-modal');
                        const isInstructionsVisible = instructionsModal && instructionsModal.style.display === 'block';

                        // Only toggle pause if instructions are not visible
                        if (!isInstructionsVisible) {
                            isPaused = !isPaused;
                            pauseScreen.style.display = isPaused ? 'block' : 'none';
                            menuElement.style.display = isPaused ? 'block' : 'none';

                            if (!isPaused) {
                                // Apply settings when resuming
                                applyGameSettings();
                            }
                        }
                    }
                });
            }

            // Rotation button
            if (rotateButton) {
                rotateButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    // Toggle rotation enabled flag
                    isRotationEnabled = !isRotationEnabled;

                    // Visual feedback - change button text
                    rotateButton.innerHTML = isRotationEnabled ? "ROTATE ON" : "ROTATE OFF";

                    // Save rotation state to localStorage
                    saveRotationState();
                });
            }

            // Variables for touch rotation and swipe detection
            let lastTouchX = 0;
            let lastTouchY = 0;
            let touchStartTime = 0;
            let lastTapTime = 0;
            let touchStartX = 0;
            let isSwiping = false;
            const SWIPE_THRESHOLD = 50; // Minimum distance for a swipe

            // Touch events for tunnel rotation and swipe detection
            if (renderer && renderer.domElement) {
                renderer.domElement.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                    touchStartX = touch.clientX; // Store initial X position for swipe detection
                    touchStartTime = Date.now();
                    isSwiping = false; // Reset swipe state

                    // Check for double tap (toggle rotation)
                    const currentTime = Date.now();
                    if (currentTime - lastTapTime < 300) { // 300ms between taps
                        // Toggle rotation enabled flag
                        isRotationEnabled = !isRotationEnabled;
                        // Save rotation state to localStorage
                        saveRotationState();
                        e.preventDefault(); // Prevent zoom
                    }
                    lastTapTime = currentTime;
                });

                renderer.domElement.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;

                    // Calculate delta movement
                    const deltaX = touchX - lastTouchX;
                    const deltaY = touchY - lastTouchY;

                    // Check for horizontal swipe
                    const swipeDistance = touchX - touchStartX;

                    // If we're playing and the swipe is significant
                    if (gameState === 'playing' && !isPaused && Math.abs(swipeDistance) > SWIPE_THRESHOLD && !isSwiping) {
                        isSwiping = true; // Mark that we've detected a swipe

                        // Determine swipe direction and trigger movement
                        if (swipeDistance < 0) {
                            // Swipe left - move right (inverted)
                            keyState['ArrowRight'] = true;
                            setTimeout(() => { keyState['ArrowRight'] = false; }, 100);
                        } else {
                            // Swipe right - move left (inverted)
                            keyState['ArrowLeft'] = true;
                            setTimeout(() => { keyState['ArrowLeft'] = false; }, 100);
                        }
                    }

                    // Handle rotation if enabled
                    if (isRotationEnabled && gameState === 'playing') {
                        // Update target rotation based on touch movement
                        targetRotationY += deltaX * 0.005;
                        targetRotationX += deltaY * 0.005;

                        // Debounced save of rotation state
                        if (saveRotationTimer) {
                            clearTimeout(saveRotationTimer);
                        }
                        saveRotationTimer = setTimeout(() => {
                            saveRotationState();
                            saveRotationTimer = null;
                        }, 500);
                    }

                    // Update last touch position
                    lastTouchX = touchX;
                    lastTouchY = touchY;
                });

                renderer.domElement.addEventListener('touchend', function(e) {
                    // Reset swipe state
                    isSwiping = false;
                });
            }
        }
    }

    // --- Initialization Function ---
    function init() {
        // Load saved rotation state
//        loadRotationState();

        // Load high score
        loadHighScore();

        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera setup
        camera = new THREE.PerspectiveCamera(
          90,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
//        camera.position.set(0, 8, WEB_DEPTH / 2 + 10);
        camera.position.set(0, .6, WEB_DEPTH / 2 + 15);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting to enhance 3D effects
        addLighting();

        // Create the initial web - it will be recreated with startGame
        createWeb(webType);

        // Create player
        createPlayer();
        player.visible = false;

        // Initial state: show menu, hide game UI/game over
        if (uiElement) uiElement.style.display = 'none';

        const powerUpsElement = document.getElementById('power-ups');
        if (powerUpsElement) powerUpsElement.style.display = 'none';

        const levelIndicatorElement = document.getElementById('level-indicator');
        if (levelIndicatorElement) levelIndicatorElement.style.display = 'none';

        if (gameOverScreen) gameOverScreen.style.display = 'none';
        if (levelCompleteScreen) levelCompleteScreen.style.display = 'none';
        if (menuElement) menuElement.style.display = 'block';

        const instructionsButton = document.getElementById('instructions-button');
        const instructionsModal = document.getElementById('instructions-modal');
        const closeInstructionsButton = document.getElementById('close-instructions-button');

        // Add event listener for instructions button
        if (instructionsButton && instructionsModal && closeInstructionsButton) {
            instructionsButton.addEventListener('click', function() {
                instructionsModal.style.display = 'block';
                isPaused = true;
            });

            closeInstructionsButton.addEventListener('click', function() {
                instructionsModal.style.display = 'none';
                isPaused = false;
            });
        }

        // Event Listeners
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        //window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);

        // Button listeners
        if (startButton) startButton.addEventListener('click', startGame);
        if (restartButton) restartButton.addEventListener('click', restartGame);
        if (nextLevelButton) nextLevelButton.addEventListener('click', nextLevel);


        // Start the animation loop
        lastFrameTime = performance.now();
        animate();
    }

    // --- Add scene lighting ---
    function addLighting() {
        // Add ambient light for base illumination
        const ambientLight = new THREE.AmbientLight(0x202020);
        scene.add(ambientLight);

        // Add directional light for shadows and depth
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);

        // Add point light at camera position for dynamic lighting
        const pointLight = new THREE.PointLight(0x0088ff, 0.8, 50);
        pointLight.position.copy(camera.position);
        scene.add(pointLight);
    }

    // --- Create Web Geometry based on selected type ---
    function createWeb(type) {
        // Remove existing web if any
        if (webMesh) {
            scene.remove(webMesh);
        }

        let shape;
        webType = type;

        switch (type) {
            case 'square':
                shape = createSquareWeb();
                NUM_LANES = 4; // 4 sides
                break;
            case 'triangle':
                shape = createTriangleWeb();
                NUM_LANES = 3; // 3 sides
                break;
            case 'pentagon':
                NUM_LANES = 5; // 5 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'hexagon':
                NUM_LANES = 6; // 6 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'octagon':
                NUM_LANES = 8; // 8 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'random':
                // Create a random polygon between 5 and 8 sides
                NUM_LANES = Math.floor(Math.random() * 4) + 5; // 5 to 8 sides
                shape = createPolygonWeb(NUM_LANES);
                break;
            case 'circle':
            default:
                // Circle-like polygon with 16 sides
                NUM_LANES = 16;
                shape = createPolygonWeb(NUM_LANES);
                break;
        }

        // Update LANE_ANGLE_STEP based on NUM_LANES
        LANE_ANGLE_STEP = (Math.PI * 2) / NUM_LANES;

        const extrudeSettings = {
            steps: 1,
            depth: WEB_DEPTH,
            bevelEnabled: false
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.translate(0, 0, -WEB_DEPTH / 2);

        // Create enhanced wireframe with tube-like effect
        const edges = new THREE.EdgesGeometry(geometry);

        // Create a group to hold all tube segments
        webMesh = new THREE.Group();

        // Get the positions from the edges geometry
        const positions = edges.attributes.position.array;

        // Create tube segments for each edge
        for (let i = 0; i < positions.length; i += 6) {
            // Each edge has two vertices (start and end)
            const startPoint = new THREE.Vector3(
              positions[i], positions[i + 1], positions[i + 2]
            );
            const endPoint = new THREE.Vector3(
              positions[i + 3], positions[i + 4], positions[i + 5]
            );

            // Create a path for the tube
            const path = new THREE.CatmullRomCurve3([startPoint, endPoint]);

            // Create tube geometry with radius proportional to web size and selected width
            let tubeRadiusMultiplier;
            switch (tubeWidth) {
                case 'wire':
                    tubeRadiusMultiplier = 0.0005;
                    break; // 0.5% of web radius
                case 'small':
                    tubeRadiusMultiplier = 0.001;
                    break; // 1% of web radius
                case 'medium':
                    tubeRadiusMultiplier = 0.002;
                    break; // 2% of web radius (default)
                case 'large':
                    tubeRadiusMultiplier = 0.004;
                    break; // 4% of web radius
                default:
                    tubeRadiusMultiplier = 0.02; // Default to medium
            }
            const tubeRadius = WEB_RADIUS * tubeRadiusMultiplier;
            const tubeGeometry = new THREE.TubeGeometry(
              path,
              1,              // tubularSegments
              tubeRadius,     // radius
              8,              // radialSegments
              false           // closed
            );

            // Create material with glow effect
            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8,
                shininess: 30
            });

            // Create mesh and add to group
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            webMesh.add(tubeMesh);
        }

        // Apply saved rotation values if available, otherwise use neutral position
        if (targetRotationX !== 0 || targetRotationY !== 0) {
            webMesh.rotation.x = targetRotationX;
            webMesh.rotation.y = targetRotationY;
        } else {
            webMesh.rotation.x = 0;
            webMesh.rotation.y = 0;
        }

        scene.add(webMesh);
    }

    // Helper functions to create different web shapes
    function createPolygonWeb(sides) {
        const shape = new THREE.Shape();
        shape.moveTo(WEB_RADIUS, 0);
        for (let i = 1; i <= sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            shape.lineTo(WEB_RADIUS * Math.cos(angle), WEB_RADIUS * Math.sin(angle));
        }
        return shape;
    }

    function createSquareWeb() {
        const shape = new THREE.Shape();
        const size = WEB_RADIUS * 1.5;
        shape.moveTo(size, size);
        shape.lineTo(-size, size);
        shape.lineTo(-size, -size);
        shape.lineTo(size, -size);
        shape.lineTo(size, size);
        return shape;
    }

    function createTriangleWeb() {
        const shape = new THREE.Shape();
        const size = WEB_RADIUS * 1.8;
        shape.moveTo(0, size);
        shape.lineTo(-size, -size / 2);
        shape.lineTo(size, -size / 2);
        shape.lineTo(0, size);
        return shape;
    }

    // --- Create Player with enhanced visuals ---
    function createPlayer() {
        // Remove existing player if any
        if (player) {
            scene.remove(player);
        }

        // Create a group to hold player elements
        player = new THREE.Group();

        // Main body (box)
        const bodyGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const bodyMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0x440000,
            shininess: 30,
            transparent: true,
            opacity: 0.9
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        player.add(body);

        // Add wings to make it look more like a spaceship
        const wingGeometry = new THREE.ConeGeometry(0.4, 1, 4);
        const wingMaterial = new THREE.MeshPhongMaterial({
            color: 0xffaa00,
            emissive: 0x441100,
            shininess: 20
        });

        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.8, 0, 0);
        leftWing.rotation.z = Math.PI / 2;
        player.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.8, 0, 0);
        rightWing.rotation.z = -Math.PI / 2;
        player.add(rightWing);

        // Add thruster effect (simple cone)
        const thrusterGeometry = new THREE.ConeGeometry(0.3, 0.6, 8);
        const thrusterMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            emissive: 0x00aaff,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
        });
        const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
        thruster.position.set(0, 0, 0.9);
        thruster.rotation.x = Math.PI;
        player.add(thruster);

        scene.add(player);
    }

    // --- Update Player Position ---
    function updatePlayerPosition() {
        // Calculate position based on current lane and web type
        let x, y;
        let angle;

        if (webType === 'square') {
            // For square web, place player at the midpoint of each side
            switch (playerCurrentLaneIndex) {
                case 0: // Top
                    x = 0;
                    y = WEB_RADIUS * 1.5;
                    break;
                case 1: // Left
                    x = -WEB_RADIUS * 1.5;
                    y = 0;
                    break;
                case 2: // Bottom
                    x = 0;
                    y = -WEB_RADIUS * 1.5;
                    break;
                case 3: // Right
                    x = WEB_RADIUS * 1.5;
                    y = 0;
                    break;
            }
            // Rotation to face inward
            angle = (playerCurrentLaneIndex * Math.PI / 2) + Math.PI / 2;
        } else if (webType === 'triangle') {
            // For triangle web, position at the three corners
            angle = (playerCurrentLaneIndex * Math.PI * 2 / 3);
            const size = WEB_RADIUS * 1.8;
            if (playerCurrentLaneIndex === 0) {
                x = 0;
                y = size;
            } else if (playerCurrentLaneIndex === 1) {
                x = -size;
                y = -size / 2;
            } else {
                x = size;
                y = -size / 2;
            }
        } else {
            // For circle or random polygon
            angle = playerCurrentLaneIndex * LANE_ANGLE_STEP;
            x = WEB_RADIUS * Math.cos(angle);
            y = WEB_RADIUS * Math.sin(angle);
        }

        // Create a position vector
        const position = new THREE.Vector3(x, y, PLAYER_Z);

        // Apply tunnel rotation to player position
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to position
            position.applyMatrix4(rotationMatrix);
        }

        // Update player position
        player.position.copy(position);

        // Update player rotation to face inward and account for tunnel rotation
        player.rotation.z = angle + Math.PI / 2;

        // Apply tunnel rotation to player orientation
        if (webMesh) {
            player.rotation.x = webMesh.rotation.x;
            player.rotation.y = webMesh.rotation.y;
        } else {
            player.rotation.x = 0;
            player.rotation.y = 0;
        }
    }

    // --- Set Game Settings ---
    function setGameSettings(speed, difficulty, web, width, lives) {
        // Player Speed
        switch (speed) {
            case 'slow':
                playerLaneChangeRate = 10;
                break;
            case 'normal':
                playerLaneChangeRate = 6;
                break;
            case 'fast':
                playerLaneChangeRate = 3;
                break;
            default:
                playerLaneChangeRate = 6;
        }

        // Difficulty
        switch (difficulty) {
            case 'easy':
                currentEnemySpeed = 0.03;
                currentEnemySpawnInterval = 80;
                enemiesPerLevel = 15;
                break;
            case 'medium':
                currentEnemySpeed = 0.05;
                currentEnemySpawnInterval = 50;
                enemiesPerLevel = 20;
                break;
            case 'hard':
                currentEnemySpeed = 0.07;
                currentEnemySpawnInterval = 30;
                enemiesPerLevel = 25;
                break;
            default:
                currentEnemySpeed = 0.05;
                currentEnemySpawnInterval = 50;
                enemiesPerLevel = 20;
        }

        // Web Type
        webType = web;

        // Tube Width
        tubeWidth = width;

        // Lives
        // Convert to integer and ensure it's within the valid range
        const livesValue = parseInt(lives);
        if (!isNaN(livesValue) && livesValue >= 3 && livesValue <= 1000) {
            // We don't set the lives variable here, it will be set in startGame
            // This is just to validate the input
        }

    }

    // --- Start Game Function ---
    function startGame() {
        if (gameState === 'playing') return;

        // Get selected settings
        const selectedSpeed = speedSelect.value;
        const selectedDifficulty = difficultySelect.value;
        const selectedWebType = webTypeSelect.value;
        const selectedTubeWidth = tubeWidthSelect.value;
        const selectedLives = livesSelect.value;

        setGameSettings(selectedSpeed, selectedDifficulty, selectedWebType, selectedTubeWidth, selectedLives);

        // Create the web based on selected type
        createWeb(selectedWebType);

        // Reset game state
        score = 0;
        lives = parseInt(selectedLives);
        level = 1;
        enemiesKilled = 0;
        enemiesRequired = enemiesPerLevel;
        enemySpawnTimer = 0;
        playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
        lastLaneChangeFrame = 0;
        activePowerUp = null;
        powerUpTimer = 0;
        bombs = 0; // Reset bombs to 0
        lastBombMilestone = 0; // Reset last bomb milestone


        // Load saved rotation state or use defaults
        //loadRotationState();

        // Clear existing game objects
        clearGameObjects();

        // Update player
        updatePlayerPosition();

        // Update UI
        updateScoreUI();
        updateHighScoreUI();
        updateLivesUI();
        updateLevelUI();
        updatePowerUpUI();
        updateEnemiesRemainingUI();
        updateBombsUI();

        uiElement.style.display = 'block';
        document.getElementById('power-ups').style.display = 'block';
        document.getElementById('level-indicator').style.display = 'block';
        gameOverScreen.style.display = 'none';
        levelCompleteScreen.style.display = 'none';
        menuElement.style.display = 'none';

        // Mobile device detection and touch controls setup
        setupMobileControls();

        gameState = 'playing';
        isPaused = false;
        player.visible = true;
    }

    // --- Reset for Next Level ---
    function nextLevel() {
        if (gameState !== 'levelcomplete') return;

        // Increase level
        level++;

        // Add 1 life for completing a level
        lives++;
        updateLivesUI();

        // Increase difficulty
        currentEnemySpeed += 0.01;
        currentEnemySpawnInterval = Math.max(currentEnemySpawnInterval - 5, 20);
        enemiesRequired = Math.min(enemiesPerLevel + (level * 5), 50);

        // Reset level-specific variables
        enemiesKilled = 0;
        enemySpawnTimer = 0;

        // Save current rotation state before transitioning to next level
        saveRotationState();

        // Choose a new random web shape for variety
        const webTypes = ['circle', 'square', 'triangle', 'pentagon', 'hexagon', 'octagon', 'random'];
        const newWebType = webTypes[Math.floor(Math.random() * webTypes.length)];
        createWeb(newWebType);

        // Reset player position after new web creation
        playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
        updatePlayerPosition();

        // Clear objects from previous level
        clearGameObjects();

        // Update UI
        updateLevelUI();
        updateEnemiesRemainingUI();
        updateBombsUI();

        // Hide level complete screen
        levelCompleteScreen.style.display = 'none';

        // Resume game
        gameState = 'playing';
        player.visible = true;
    }

    // --- Restart Game Function ---
    function restartGame() {
        gameState = 'menu';
        gameOverScreen.style.display = 'none';
        menuElement.style.display = 'block';
        uiElement.style.display = 'none';
        document.getElementById('power-ups').style.display = 'none';
        document.getElementById('level-indicator').style.display = 'none';

        // Clear AI auto-restart countdown if active
        clearAIRestartCountdown();

        player.visible = false;
        clearGameObjects();
    }

    // --- Clear all game objects ---
    function clearGameObjects() {
        // Remove all enemies
        enemies.forEach(enemy => scene.remove(enemy));
        enemies.length = 0;

        // Remove all projectiles
        projectiles.forEach(p => scene.remove(p));
        projectiles.length = 0;

        // Remove all power-ups
        powerUps.forEach(p => scene.remove(p));
        powerUps.length = 0;

        // Remove all explosions
        explosions.forEach(e => scene.remove(e));
        explosions.length = 0;
    }

    // --- Create Standard Projectile ---
    function createProjectile(isSuperProjectile = false) {
        if (gameState !== 'playing' || isPaused) return;

        // Limit standard projectiles (unless super power active)
        if (!isSuperProjectile && !activePowerUp && projectiles.length > 5) return;

        const projectileGeometry = new THREE.BoxGeometry(0.3, 0.3, 2);

        // Different appearance for super projectiles
        const projectileMaterial = isSuperProjectile ?
          new THREE.MeshPhongMaterial({
              color: 0xff00ff,
              emissive: 0x880088,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.8
          }) :
          new THREE.MeshPhongMaterial({
              color: 0xffff00,
              emissive: 0x888800,
              emissiveIntensity: 0.3
          });

        const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

        // Position at player
        projectile.position.copy(player.position);
        projectile.position.z -= 1.5;

        // Copy player's rotation to align with tunnel rotation
        projectile.rotation.copy(player.rotation);

        // Store projectile properties
        projectile.laneIndex = playerCurrentLaneIndex;
        projectile.isSuper = isSuperProjectile;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, -1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        projectile.direction = direction.normalize();

        scene.add(projectile);
        projectiles.push(projectile);

        // Play sound
        // sounds.fire.play();
    }

    // --- Create Enemy ---
    function createEnemy(isSpecial = false) {
        if (gameState !== 'playing' || isPaused) return;

        // Geometry based on enemy type
        const enemyGeometry = isSpecial ?
          new THREE.OctahedronGeometry(1.2) :
          new THREE.TetrahedronGeometry(1);

        // Material based on enemy type
        const enemyMaterial = isSpecial ?
          new THREE.MeshPhongMaterial({
              color: 0xff0000,
              emissive: 0x880000,
              emissiveIntensity: 0.5,
              shininess: 30
          }) :
          new THREE.MeshPhongMaterial({
              color: 0x00ff00,
              emissive: 0x008800,
              emissiveIntensity: 0.3,
              shininess: 20
          });

        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);

        // Random lane
        const laneIndex = Math.floor(Math.random() * NUM_LANES);

        // Position depends on web type
        let x, y;
        let angle;

        if (webType === 'square') {
            switch (laneIndex) {
                case 0: // Top
                    x = 0;
                    y = WEB_RADIUS * 1.5;
                    break;
                case 1: // Left
                    x = -WEB_RADIUS * 1.5;
                    y = 0;
                    break;
                case 2: // Bottom
                    x = 0;
                    y = -WEB_RADIUS * 1.5;
                    break;
                case 3: // Right
                    x = WEB_RADIUS * 1.5;
                    y = 0;
                    break;
            }
            angle = (laneIndex * (Math.PI * 2) / NUM_LANES);
        } else if (webType === 'triangle') {
            const size = WEB_RADIUS * 1.8;
            if (laneIndex === 0) {
                x = 0;
                y = size;
            } else if (laneIndex === 1) {
                x = -size;
                y = -size / 2;
            } else {
                x = size;
                y = -size / 2;
            }
            angle = (laneIndex * (Math.PI * 2) / NUM_LANES);
        } else {
            angle = laneIndex * LANE_ANGLE_STEP;
            x = WEB_RADIUS * Math.cos(angle);
            y = WEB_RADIUS * Math.sin(angle);
        }

        // Create a position vector
        const position = new THREE.Vector3(x, y, ENEMY_START_Z);

        // Apply tunnel rotation to enemy position
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to position
            position.applyMatrix4(rotationMatrix);
        }

        // Set enemy position
        enemy.position.copy(position);

        // Rotate enemy to face roughly towards the center
        enemy.rotation.z = angle;

        // Apply tunnel rotation to enemy orientation
        if (webMesh) {
            enemy.rotation.x = webMesh.rotation.x;
            enemy.rotation.y = webMesh.rotation.y;
        }

        // Add pulsating animation
        enemy.initialScale = isSpecial ? 1.2 : 1.0;
        enemy.pulsePhase = Math.random() * Math.PI * 2; // Random starting phase

        // Store enemy properties
        enemy.laneIndex = laneIndex;
        enemy.isSpecial = isSpecial;
        enemy.points = isSpecial ? 200 : 100;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, 1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        enemy.direction = direction.normalize();

        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- Create Power-Up ---
    function createPowerUp(position) {
        const powerTypes = ['rapidFire', 'extraLife', 'shield', 'superProjectile'];
        const powerType = powerTypes[Math.floor(Math.random() * powerTypes.length)];

        // Create power-up object
        const powerGeometry = new THREE.SphereGeometry(0.8, 8, 8);

        // Color based on power-up type
        let powerColor;
        switch (powerType) {
            case 'rapidFire':
                powerColor = 0xffaa00;
                break; // Orange
            case 'extraLife':
                powerColor = 0xff0000;
                break; // Red
            case 'shield':
                powerColor = 0x0088ff;
                break; // Blue
            case 'superProjectile':
                powerColor = 0xff00ff;
                break; // Magenta
            default:
                powerColor = 0xffffff; // White
        }

        const powerMaterial = new THREE.MeshPhongMaterial({
            color: powerColor,
            emissive: powerColor,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9,
            shininess: 50
        });

        const powerUp = new THREE.Mesh(powerGeometry, powerMaterial);

        // Position at enemy death location (passed in as argument)
        powerUp.position.copy(position);

        // Apply tunnel rotation to power-up orientation
        if (webMesh) {
            powerUp.rotation.x = webMesh.rotation.x;
            powerUp.rotation.y = webMesh.rotation.y;
        }

        // Store power-up properties
        powerUp.powerType = powerType;
        powerUp.rotationSpeed = 0.05;

        // Store direction vector for movement (accounting for tunnel rotation)
        const direction = new THREE.Vector3(0, 0, 1);
        if (webMesh) {
            // Create a rotation matrix from the web's rotation
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
              webMesh.rotation.x,
              webMesh.rotation.y,
              0 // Don't apply z rotation as it's just for visual effect
            ));

            // Apply rotation to direction
            direction.applyMatrix4(rotationMatrix);
        }
        powerUp.direction = direction.normalize();

        scene.add(powerUp);
        powerUps.push(powerUp);

        return powerUp;
    }

    // --- Create Explosion Effect ---
    function createExplosion(position, color) {
        const particleCount = 15;
        const explosionGroup = new THREE.Group();
        explosionGroup.position.copy(position);

        // Create particles
        for (let i = 0; i < particleCount; i++) {
            const particleGeometry = new THREE.SphereGeometry(0.2, 6, 6);
            const particleMaterial = new THREE.MeshPhongMaterial({
                color: color || 0xffaa00,
                emissive: color || 0xffaa00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });

            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // Random position within explosion radius
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = Math.random() * 0.5;

            particle.position.set(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );

            // Random velocity
            particle.velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2
            );

            // Lifespan in milliseconds
            particle.life = 500;
            particle.maxLife = 500;

            explosionGroup.add(particle);
        }

        // Add to scene
        scene.add(explosionGroup);
        explosions.push(explosionGroup);

        // Play explosion sound
        // sounds.explode.play();

        return explosionGroup;
    }

    // --- Apply Power-Up ---
    function applyPowerUp(powerType) {
        // Clear any existing power-up
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
        }

        activePowerUp = powerType;
        updatePowerUpUI();

        // Apply power-up effect
        switch (powerType) {
            case 'rapidFire':
                // Rapid fire handled in update loop
                break;
            case 'extraLife':
                lives++;
                updateLivesUI();
                activePowerUp = null; // Immediate effect
                break;
            case 'shield':
                // Shield is handled in collision detection
                break;
            case 'superProjectile':
                // Super projectiles handled in projectile creation and collision
                break;
        }

        // Set timeout to clear power-up after duration (except extraLife which is immediate)
        if (powerType !== 'extraLife') {
            powerUpTimer = setTimeout(() => {
                activePowerUp = null;
                updatePowerUpUI();
            }, POWER_UP_DURATION);
        }

        // Play power-up sound
        // sounds.powerUp.play();
    }

    // --- Update Game State (per frame) ---
    function update(deltaTime) {
        if (gameState !== 'playing' || isPaused) {
            return;
        }

        const currentFrame = renderer.info.render.frame;


        // --- Update player position to account for tunnel rotation ---
        if (webMesh) {
            updatePlayerPosition();
        }

        // --- Player Movement ---
        let laneChangeAttempt = false;
        let newLaneIndex = playerCurrentLaneIndex;

        if (keyState['ArrowLeft']) {
            newLaneIndex = (playerCurrentLaneIndex + 1) % NUM_LANES;
            laneChangeAttempt = true;
        } else if (keyState['ArrowRight']) {
            newLaneIndex = (playerCurrentLaneIndex - 1 + NUM_LANES) % NUM_LANES;
            laneChangeAttempt = true;
        }

        if (laneChangeAttempt && currentFrame >= lastLaneChangeFrame + playerLaneChangeRate) {
            playerCurrentLaneIndex = newLaneIndex;
            updatePlayerPosition();
            lastLaneChangeFrame = currentFrame;
        }

        // Handle automatic firing for rapid fire power-up
        if (activePowerUp === 'rapidFire' && currentFrame % 5 === 0) {
            createProjectile();
        }

        // --- Update Projectiles ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const projectile = projectiles[i];

            // Move projectile along its direction vector (accounting for tunnel rotation)
            if (projectile.direction) {
                projectile.position.x += projectile.direction.x * PROJECTILE_SPEED;
                projectile.position.y += projectile.direction.y * PROJECTILE_SPEED;
                projectile.position.z += projectile.direction.z * PROJECTILE_SPEED;
            } else {
                // Fallback for projectiles created before this update
                projectile.position.z -= PROJECTILE_SPEED;
            }

            // Super projectiles have a trailing effect
            if (projectile.isSuper && Math.random() > 0.5) {
                const trailGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.5
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.copy(projectile.position);
                scene.add(trail);

                // Fade out trail
                setTimeout(() => {
                    scene.remove(trail);
                    trail.geometry.dispose();
                    trail.material.dispose();
                }, 500);
            }

            // Remove projectile if off screen
            if (projectile.position.z < ENEMY_START_Z - 5) {
                scene.remove(projectile);
                projectiles.splice(i, 1);
            }
        }

        // --- Update Enemies ---
        enemySpawnTimer++;

        // Spawn enemies until we've reached the level's required number
        if (enemySpawnTimer >= currentEnemySpawnInterval && enemies.length < enemiesRequired - enemiesKilled) {
            // Chance to spawn special enemy
            const isSpecial = Math.random() < SPECIAL_ENEMY_CHANCE;
            createEnemy(isSpecial);
            enemySpawnTimer = 0;
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];

            // Move enemy along its direction vector (accounting for tunnel rotation)
            const speed = currentEnemySpeed * (enemy.isSpecial ? 1.2 : 1.0);
            if (enemy.direction) {
                enemy.position.x += enemy.direction.x * speed;
                enemy.position.y += enemy.direction.y * speed;
                enemy.position.z += enemy.direction.z * speed;
            } else {
                // Fallback for enemies created before this update
                enemy.position.z += speed;
            }

            // Pulsating animation
            const pulseScale = enemy.initialScale + Math.sin(enemy.pulsePhase) * 0.1;
            enemy.pulsePhase += 0.05;
            enemy.scale.set(pulseScale, pulseScale, pulseScale);

            // Special enemies also rotate
            if (enemy.isSpecial) {
                enemy.rotation.y += 0.03;
                enemy.rotation.x += 0.02;
            }

            // Check if enemy reached the player's end
            if (enemy.position.z > ENEMY_END_Z) {
                // Player loses a life if not shielded
                if (activePowerUp !== 'shield') {
                    loseLife();
                } else {
                    // Shield absorbs one hit
                    activePowerUp = null;
                    updatePowerUpUI();
                    clearTimeout(powerUpTimer);

                    // Visual effect for shield hit
                    createExplosion(enemy.position, 0x0088ff);
                }

                scene.remove(enemy);
                enemies.splice(i, 1);

                if (gameState !== 'playing') return;
            }
        }

        // --- Update Power-Ups ---
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];

            // Move power-up towards player along its direction vector (accounting for tunnel rotation)
            const speed = currentEnemySpeed * 1.5; // Increased from 0.5 to 1.5 to make power-ups three times faster
            if (powerUp.direction) {
                powerUp.position.x += powerUp.direction.x * speed;
                powerUp.position.y += powerUp.direction.y * speed;
                powerUp.position.z += powerUp.direction.z * speed;
            } else {
                // Fallback for power-ups created before this update
                powerUp.position.z += speed;
            }

            // Rotate power-up
            powerUp.rotation.y += powerUp.rotationSpeed;
            powerUp.rotation.x += powerUp.rotationSpeed * 0.7;

            // Pulsate size
            const pulseScale = 1 + 0.1 * Math.sin(performance.now() * 0.005);
            powerUp.scale.set(pulseScale, pulseScale, pulseScale);

            // Check if power-up is collected
            if (powerUp.position.z > PLAYER_Z - 1 &&
              Math.abs(powerUp.position.x - player.position.x) < 2 &&
              Math.abs(powerUp.position.y - player.position.y) < 2) {

                // Collect power-up
                applyPowerUp(powerUp.powerType);

                // Remove power-up
                scene.remove(powerUp);
                powerUps.splice(i, 1);
            }

            // Remove if past player
            if (powerUp.position.z > PLAYER_Z + 5) {
                scene.remove(powerUp);
                powerUps.splice(i, 1);
            }
        }

        // --- Update Explosions ---
        for (let i = explosions.length - 1; i >= 0; i--) {
            const explosion = explosions[i];
            let removeExplosion = true;

            // Update each particle
            explosion.children.forEach(particle => {
                particle.position.add(particle.velocity);
                particle.life -= deltaTime;

                // Fade out particle
                if (particle.life > 0) {
                    particle.material.opacity = particle.life / particle.maxLife;
                    removeExplosion = false;
                } else {
                    particle.material.opacity = 0;
                }
            });

            // Remove explosion if all particles are dead
            if (removeExplosion) {
                // Clean up all particles
                explosion.children.forEach(particle => {
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
                scene.remove(explosion);
                explosions.splice(i, 1);
            }
        }

        // --- Collision Detection (Projectile vs Enemy) ---
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const projectile = projectiles[i];
            let projectileHit = false;

            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];

                // Check if in same lane and close enough on Z axis
                if (projectile.laneIndex === enemy.laneIndex &&
                  Math.abs(projectile.position.z - enemy.position.z) < COLLISION_Z_TOLERANCE) {

                    // Collision detected!
                    const hitPoints = enemy.points;
                    addScore(hitPoints);
                    enemiesKilled++;
                    updateEnemiesRemainingUI();

                    // Create explosion effect
                    createExplosion(enemy.position, enemy.isSpecial ? 0xff0000 : 0x00ff00);

                    // Chance to spawn power-up
                    if (Math.random() < POWER_UP_CHANCE || enemy.isSpecial) {
                        createPowerUp(enemy.position);
                    }

                    // Remove enemy
                    scene.remove(enemy);
                    enemies.splice(j, 1);

                    // Super projectiles can pass through enemies
                    if (!projectile.isSuper) {
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        projectileHit = true;
                    }

                    // Check if level is complete
                    if (enemiesKilled >= enemiesRequired) {
                        completedLevel();
                    }

                    // Break inner loop if projectile was destroyed
                    if (projectileHit) break;
                }
            }
        }
    }

    // --- Game Over Logic ---
    function loseLife() {
        if (gameState !== 'playing') return;

        lives--;
        updateLivesUI();

        // Visual indication
        createExplosion(player.position, 0xff0000);

        // Make player flash
        let flashCount = 0;
        const flashInterval = setInterval(() => {
            player.visible = !player.visible;
            flashCount++;
            if (flashCount >= 6) {
                clearInterval(flashInterval);
                player.visible = true;
            }
        }, 200);

        if (lives <= 0) {
            endGame();
        }
    }

    function endGame() {
        if (gameState !== 'playing') return;

        // Save rotation state before ending the game
        saveRotationState();

        gameState = 'gameover';
        finalScoreUI.textContent = 'FINAL SCORE: ' + score;
        finalHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
        gameOverScreen.style.display = 'block';
        uiElement.style.display = 'none';
        document.getElementById('power-ups').style.display = 'none';
        document.getElementById('level-indicator').style.display = 'none';

        // Clear game objects
        clearGameObjects();

        // Hide player
        player.visible = false;

        // Clear power-up timer
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
            activePowerUp = null;
        }


    }


    // --- Level Complete Logic ---
    function completedLevel() {
        if (gameState !== 'playing') return;

        // Save rotation state before completing the level
        saveRotationState();

        // If in auto mode, automatically proceed to next level after a short delay
        if (isAIAutoMode) {
            // Update AI learning for level completion
            if (isAIEnabled && aiLearning.lastState && aiLearning.lastAction) {
                // Large positive reward for completing a level
                const levelCompletionReward = 200 + (level * 50); // Increases with level
                updateQValue(aiLearning.lastState, aiLearning.lastAction, levelCompletionReward, null);

                // Reset last state and action for next level
                aiLearning.lastState = null;
                aiLearning.lastAction = null;

                // Save AI learning data
                saveAILearningData();
            }

            // Proceed to next level after a short delay
            setTimeout(nextLevel, 2000);

            // Show level complete screen briefly
            gameState = 'levelcomplete';
            levelScoreUI.textContent = 'LEVEL ' + level + ' SCORE: ' + score;
            levelHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
            levelCompleteScreen.style.display = 'block';
            return;
        }

        // Clear AI auto-restart countdown if active and not in auto mode
        clearAIRestartCountdown();

        gameState = 'levelcomplete';
        levelScoreUI.textContent = 'LEVEL ' + level + ' SCORE: ' + score;
        levelHighScoreUI.textContent = 'HIGH SCORE: ' + highScore;
        levelCompleteScreen.style.display = 'block';

        // Bonus points for completing level
        const levelBonus = level * 500;
        addScore(levelBonus);

        // Play level complete sound
        // sounds.levelComplete.play();

        // Clear power-up timer
        if (activePowerUp) {
            clearTimeout(powerUpTimer);
            activePowerUp = null;
        }

        // Hide player
        player.visible = false;

    }

    // --- UI Updates ---
    function addScore(points) {
        score += points;
        updateScoreUI();

        // Update high score if current score is higher
        if (score > highScore) {
            highScore = score;
            updateHighScoreUI();
            saveHighScore();
        }

        // Check for bomb reward milestone (every 1000 points)
        const currentMilestone = Math.floor(score / BOMB_POINTS);
        if (currentMilestone > lastBombMilestone) {
            // Award a new bomb for each milestone passed
            const newBombs = currentMilestone - lastBombMilestone;

            // Add bombs, but don't exceed the maximum of 30000000
            bombs = Math.min(bombs + newBombs, 3000000);

            // Update the last milestone
            lastBombMilestone = currentMilestone;

            // Update the bombs UI
            updateBombsUI();

            // Visual feedback for getting a new bomb
            const message = newBombs === 1 ? "NEW BOMB ACQUIRED!" : newBombs + " NEW BOMBS ACQUIRED!";
            showMessage(message, 0xffff00);
        }
    }

    // Helper function to show temporary messages
    function showMessage(text, color) {
        // Create a div for the message
        const messageDiv = document.createElement('div');
        messageDiv.textContent = text;
        messageDiv.style.position = 'absolute';
        messageDiv.style.top = '50%';
        messageDiv.style.left = '50%';
        messageDiv.style.transform = 'translate(-50%, -50%)';
        messageDiv.style.color = '#' + color.toString(16);
        messageDiv.style.textShadow = '0 0 10px #' + color.toString(16);
        messageDiv.style.fontSize = '2em';
        messageDiv.style.fontFamily = "Orbitron, sans-serif";
        messageDiv.style.zIndex = '1000';
        messageDiv.style.pointerEvents = 'none';

        // Add to document
        document.body.appendChild(messageDiv);

        // Fade out and float up after 2 seconds
        setTimeout(() => {
            messageDiv.style.transition = 'opacity 1s, transform 1s';
            messageDiv.style.opacity = '0';
            messageDiv.style.transform = 'translate(-50%, -150%)'; // Move upward while fading
            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 1000);
        }, 1000);
    }

    function updateScoreUI() {
        scoreUI.textContent = 'SCORE: ' + score;
    }

    function updateHighScoreUI() {
        highScoreUI.textContent = 'HIGH SCORE: ' + highScore;
    }

    function updateLivesUI() {
        livesUI.textContent = 'LIVES: ' + lives;
    }

    function updateLevelUI() {
        levelUI.textContent = 'LEVEL: ' + level;
    }

    function updatePowerUpUI() {
        let powerText = 'POWER: ';

        switch (activePowerUp) {
            case 'rapidFire':
                powerText += 'RAPID FIRE';
                break;
            case 'shield':
                powerText += 'SHIELD';
                break;
            case 'superProjectile':
                powerText += 'SUPER SHOT';
                break;
            default:
                powerText += 'NONE';
        }

        powerUpUI.textContent = powerText;
    }

    function updateEnemiesRemainingUI() {
        const remaining = Math.max(0, enemiesRequired - enemiesKilled);
        enemiesRemainingUI.textContent = 'ENEMIES: ' + remaining + '/' + enemiesRequired;
    }

    function updateBombsUI() {
        bombsUI.textContent = 'BOMBS: ' + bombs;
    }



    // Helper function to find the lane index for a given position
    function findLaneForPosition(position) {
        // This is a simplified version that works best for circular webs
        // For other web types, more complex calculations would be needed
        let angle = Math.atan2(position.y, position.x);
        if (angle < 0) angle += Math.PI * 2;

        return Math.floor(angle / LANE_ANGLE_STEP) % NUM_LANES;
    }

    // --- Web Rotation Update ---
    function updateWebRotation() {
        if (webMesh) {
            // Smoothly interpolate current rotation towards target rotation only if rotation is enabled and game is not over
            if (isRotationEnabled && gameState !== 'gameover' && gameState !== 'levelcomplete') {
                webMesh.rotation.y += (targetRotationY - webMesh.rotation.y) * 0.05;
                webMesh.rotation.x += (targetRotationX - webMesh.rotation.x) * 0.05;
            }

            // Keep subtle z-rotation for visual effect regardless of rotation enabled state
            webMesh.rotation.z += 0.0005;
        }
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);

        // Calculate delta time
        const currentTime = performance.now();
        const deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        // Always update web rotation, even when paused
        //updateWebRotation();

        // Update game state
        if (!isPaused) {
            update(deltaTime);
        }

        // Render
        renderer.render(scene, camera);
    }

    // --- Event Handlers ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
        keyState[event.key] = true;

        // Handle firing
        if (gameState === 'playing' && event.key === ' ') {
            // Create super projectile if power-up is active
            createProjectile(activePowerUp === 'superProjectile');
        }

        // Handle bomb activation
        if (gameState === 'playing' && !isPaused && event.key.toLowerCase() === 'b') {
            activateBomb();
        }

        // Toggle pause
        if (gameState === 'playing' && (event.key === 'p' || event.key === 'Enter')) {
            // Check if instructions modal is visible
            const instructionsModal = document.getElementById('instructions-modal');
            const isInstructionsVisible = instructionsModal && instructionsModal.style.display === 'block';

            // Only toggle pause if instructions are not visible
            if (!isInstructionsVisible) {
                isPaused = !isPaused;
                pauseScreen.style.display = isPaused ? 'block' : 'none';
                menuElement.style.display = isPaused ? 'block' : 'none';

                if (!isPaused) {
                    // Apply settings when resuming
                    applyGameSettings();
                }
            }
        }

        // Prevent scrolling when pressing space, arrow keys, or Enter
        if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', 'b', 'B'].includes(event.key)) {
            event.preventDefault();
        }
    }

    function onKeyUp(event) {
        keyState[event.key] = false;
    }

    function onMouseMove(event) {
        // Calculate mouse position relative to the center of the screen
        mouseX = (event.clientX - window.innerWidth / 2) / (window.innerWidth / 2);
        mouseY = (event.clientY - window.innerHeight / 2) / (window.innerHeight / 2);

        // Set target rotation based on mouse position only if rotation is enabled and game is not over
        if (isRotationEnabled && gameState !== 'gameover' && gameState !== 'levelcomplete') {
            targetRotationY = mouseX * 0.5; // Horizontal movement controls Y rotation
            targetRotationX = mouseY * 0.3; // Vertical movement controls X rotation

            // Debounced save of rotation state
            if (saveRotationTimer) {
                clearTimeout(saveRotationTimer);
            }
            saveRotationTimer = setTimeout(() => {
                saveRotationState();
                saveRotationTimer = null;
            }, 500); // Save after 500ms of no movement
        }
    }

    function onMouseClick(event) {
        // Allow toggling rotation if game is playing, even when paused
        if (gameState === 'playing') {
            // Toggle rotation enabled flag
            isRotationEnabled = !isRotationEnabled;

            // Save rotation state to localStorage
            saveRotationState();
        }
    }

    // --- Bomb Activation Function ---
    function activateBomb() {
        // Check if there are bombs available
        if (bombs <= 0) return;

        // Decrease bomb count
        bombs--;
        updateBombsUI();

        // Create a large explosion effect at the center of the web
        const centerExplosion = createExplosion(new THREE.Vector3(0, 0, 0), 0xff0000);
        centerExplosion.scale.set(3, 3, 3); // Make the explosion larger

        // Track total points from destroyed enemies
        let totalPoints = 0;

        // Destroy all visible enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];

            // Add points for each enemy
            totalPoints += enemy.points;

            // Create explosion effect at enemy position
            createExplosion(enemy.position, enemy.isSpecial ? 0xff0000 : 0x00ff00);

            // Remove enemy
            scene.remove(enemy);
            enemies.splice(i, 1);

            // Increment enemies killed count
            enemiesKilled++;
        }

        // Add score for destroyed enemies
        if (totalPoints > 0) {
            addScore(totalPoints);
            updateEnemiesRemainingUI();
        }

        // Check if level is complete
        if (enemiesKilled >= enemiesRequired) {
            completedLevel();
        }
    }

    // --- Apply Game Settings ---
    function applyGameSettings() {
        // Get selected settings
        const selectedSpeed = speedSelect.value;
        const selectedDifficulty = difficultySelect.value;
        const selectedWebType = webTypeSelect.value;
        const selectedTubeWidth = tubeWidthSelect.value;
        const selectedLives = livesSelect.value;
        const selectedAIPlayer = aiPlayerSelect.value;

        // Apply settings
        setGameSettings(selectedSpeed, selectedDifficulty, selectedWebType, selectedTubeWidth, selectedLives, selectedAIPlayer);

        // Recreate the web if the web type has changed
        if (webType !== selectedWebType) {
            createWeb(selectedWebType);
            // Reset player position after new web creation
            playerCurrentLaneIndex = Math.floor(NUM_LANES / 2);
            updatePlayerPosition();
        }
    }

    // --- Start the Game ---
    init();
</script>
</body>
</html>
